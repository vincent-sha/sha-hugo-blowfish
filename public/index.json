
[{"content":" 深入掌握 Swift 6.2 并发编程 # 介绍 # Swift 并发编程已成为 SwiftUI 多线程处理的基石。继 GCD 之后，Swift 并发于 WWDC21 发布，并在 Swift 6.0 版本引入了严格并发、sending关键字及数据竞态安全。2025年 WWDC25 发布的 Swift 6.2 版本带来了“默认 Actor 隔离”（Default Actor Isolation）和新的 nonsending 关键字，进一步简化并发开发。\n本文将从基础讲起，结合最新 Swift 6.2 特性，逐步解析 Swift 并发的核心原理与使用技巧。\nSwift 并发基础 # 线程与隔离 # Swift 支持多线程编程，每个线程拥有独立的调用栈，但共享由 ARC 管理的堆内存。主线程负责 UI 更新，避免 UI 在后台线程被修改。\nfunc someComputation() { // 运行于主线程 } 若主线程同时承担 UI 更新和复杂业务逻辑，易导致界面卡顿。借助 Swift 并发，我们可将耗时任务转移至后台线程。\nasync 和 await # async 标记异步函数，表明函数体运行在后台线程。 await 用于调用异步函数，表示代码在此处可能挂起等待异步任务完成。 class Model { func fetchingData() async { // 后台线程执行 } func fetchingDataCaller() async { await fetchingData() // 挂起并等待 } } actor 与隔离 # actor 用于保护共享状态，避免数据竞态。Swift 6.2 引入默认的 MainActor 隔离，所有类型默认运行于主线程，简化 UI 相关代码安全访问。\n@MainActor class Model { func updateUI() async { // 始终运行于主线程 } } 也可通过 nonisolated 关键字标记非隔离方法，允许在后台线程执行。\n发送与闭包捕获 # Swift 6 用 sending 替代了旧的 @Sendable，允许异步闭包更灵活地捕获非 Sendable 类型，但仍需避免跨线程数据修改。\nSwift 6.2 新特性详解 # 默认 Actor 隔离（Default Actor Isolation） # Xcode 26 默认开启此功能，项目中所有自定义类型默认继承 @MainActor，极大减少数据竞态风险。示例：\nclass Model { func fetchingData() async { // 仍运行主线程，只在 await 时切到后台执行网络请求 let (data, _) = try await URLSession.shared.data(from: url) } } nonsending 关键字 # 配合 nonisolated 使用，表示该方法不涉及发送（sending）权限，继承调用者线程上下文。\nnonisolated(nonsending) func asynchronousNonIsolated() async { // 继承调用线程 } @concurrent 宏 # 标记方法始终运行于后台线程，适合耗时操作。\n@concurrent func computeHeavyTask() { // 始终后台执行 } 并发编程最佳实践 # 线程切换示例 # class ConcurrentThread { func firstMethod() async { await secondMethod() // 先在主线程等待 await thirdMethod() // 主线程执行 } @concurrent func secondMethod() async { try? await Task.sleep(for: .seconds(1)) await thirdMethod() // 后台线程执行 } nonisolated func thirdMethod() async { // 继承调用线程 } } 解决闭包内的 @Sendable 限制 # 由于 @Sendable 闭包禁止访问 @MainActor 同步方法，推荐将调用逻辑提前或直接使用属性包装器的 wrappedValue 访问。\n结构化并发示例 # class StructuredConcurrency { var albums: [Album] = [] func fetchAlbums() async throws { try await checkAuthorizationStatus() let response = try await MusicLibraryRequest\u0026lt;Album\u0026gt;().response() albums = Array(response.items) } func processAlbums() async throws { await withThrowingTaskGroup(of: AlbumProcessingResult?.self) { group in for album in albums { group.addTask { // 并发处理 return try await processAlbum(album) } } for await result in group { // 处理结果 } } } } 利用 @concurrent 优化性能，避免主线程过载。\n总结 # Swift 6.2 并发带来了更加安全且易用的默认行为：\n默认 MainActor 隔离：代码默认运行于主线程，防止数据竞态。 非隔离方法自动 nonsending：简化后台执行代码书写。 @concurrent 宏：明确后台执行耗时任务。 这极大降低了并发编程的门槛，让开发者能专注业务逻辑，提升应用性能和稳定性。记住：\n从主线程开始，遇到耗时操作用 @concurrent，Swift 的新并发机制会帮你处理其余细节。\n祝你 Swift 编程愉快！❤️\n","date":"2026-01-04","externalUrl":null,"permalink":"/posts/mastering-swift-6-2-concurrency/","section":"文章","summary":"","title":" Swift 6.2 最新并发教程","type":"posts"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/swift/","section":"标签","summary":"","title":"Swift","type":"tags"},{"content":" Swift 6.2 新功能大详解 # Swift 6.2 作为 Swift 6 的第二个版本，内置于 Xcode 26，带来了标识符字符范围扩展、字符串插值默认值、InlineArray 固定大小数组、新的枚举返回类型遵守 Collection、weak let 弱引用常量、运行时堆栈追踪 Backtrace 结构体，以及并发编程中 nonisolated 异步函数执行行为的调整等多项重要特性。本文详细介绍了这些新特性的用法与示例，助力 Swift 开发者快速掌握。\n1. 标识符字符范围显著扩展 # Swift 6.2 允许在反引号（``）中使用更多随意的字符来定义标识符，支持使用空格或数字作为标识符名。\nfunc `this is a function`(param: String) -\u0026gt; String { return \u0026#34;Hello, \\\\(param)\u0026#34; } enum HTTPStatus: String { case `200` = \u0026#34;Success\u0026#34; case `404` = \u0026#34;Not Found\u0026#34; case `500` = \u0026#34;Internal Server Error\u0026#34; } 这种语法使得代码更加灵活，适合动态或特殊命名场景。\n2. 字符串插值支持默认值 # 字符串插值新增了 default 参数，针对可选类型的插值，当值为 nil 时可以提供默认显示内容。\nvar name: String? = nil // Swift 6.2 之前 print(\u0026#34;Hello, \\\\(name ?? \u0026#34;zhangsan\u0026#34;)!\u0026#34;) // Swift 6.2 之后 print(\u0026#34;Hello, \\\\(name, default: \u0026#34;zhangsan\u0026#34;)!\u0026#34;) 此特性简化了可选值处理，使代码更简洁清晰。\n3. InlineArray：固定大小数组类型 # 引入了 InlineArray 类型，表示固定大小的数组，优化性能，适合存储固定数量元素。\nvar array: InlineArray\u0026lt;3, String\u0026gt; = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] var array2: InlineArray = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] 这种类型有助于减少堆分配，提高访问速度。\n4. enumerated() 返回类型遵守 Collection 协议 # enumerated() 函数返回的类型现在直接遵守 Collection，简化在 SwiftUI 等中使用。\n示例：\nimport SwiftUI struct ContentView: View { @State private var names = [\u0026#34;ZhangSan\u0026#34;, \u0026#34;LiSi\u0026#34;, \u0026#34;WangWu\u0026#34;] var body: some View { // Swift 6.2 之前 List(Array(names.enumerated()), id: \\\\.element) { tuple in HStack { Text(\u0026#34;\\\\(tuple.offset)\u0026#34;) Text(tuple.element) } } // Swift 6.2 之后 List(names.enumerated(), id: \\\\.element) { tuple in HStack { Text(\u0026#34;\\\\(tuple.offset)\u0026#34;) Text(tuple.element) } } } } 5. weak let：不可变弱引用 # Swift 6.2 新增了 weak let，允许声明不可变的弱引用属性，解决 Sendable 类型中弱引用的问题。\nimport UIKit class ViewController: UIViewController { // Swift 6.2 之前 @IBOutlet weak var redView: UIView! // Swift 6.2 之后 @IBOutlet weak let greenView: UIView! override func viewDidLoad() { super.viewDidLoad() } } 这增强了内存管理的灵活性。\n6. Backtrace：运行时堆栈追踪结构体 # 新增 Backtrace 结构体支持运行时捕获堆栈调用序列，方便调试和错误定位。\nimport Runtime func functionOne() { do { if let frames = try? Backtrace.capture().symbolicated()?.frames { print(frames) } else { print(\u0026#34;Failed to capture backtrace.\u0026#34;) } } catch { print(error.localizedDescription) } } func functionTwo() { functionOne() } func functionThree() { functionTwo() } functionThree() 此功能为开发者提供了强大的诊断工具。\n7. 并发编程调整 # Swift 6.2 之前，nonisolated 异步函数自动在后台线程执行。 Swift 6.2 之后，nonisolated 异步函数默认在调用者的 actor 上执行。 通过 @concurrent 修饰，函数仍可在后台线程执行，创建新的隔离环境，要求参数和返回值符合 Sendable 协议。 适用场景包括耗时长、CPU 密集或可能阻塞线程的操作，如大规模数据转换和 I/O。\n示例：\nactor SomeActor { // 不允许 @concurrent func doSomething() async throws { } // 允许 @concurrent nonisolated func doAnotherthing() async throws { } } ","date":"2026-01-04","externalUrl":null,"permalink":"/posts/swift-6-2-new-features-xcode26/","section":"文章","summary":"","title":"Swift 6.2 新功能大详解","type":"posts"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/swift6.2/","section":"标签","summary":"","title":"Swift6.2","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/swiftui/","section":"标签","summary":"","title":"SwiftUI","type":"tags"},{"content":" SwiftUI布局结构全面讲解 # SwiftUI的布局结构是其声明式编程范式的核心，允许开发者通过简单的视图组合和修饰符来描述用户界面“应该是什么样子”，而非手动计算位置和尺寸。框架会自动处理渲染、响应式调整（如不同设备屏幕）和动画。这种方法依赖于 View 协议，所有布局组件都符合该协议，并通过 @ViewBuilder属性构建视图层次。布局是分层的：从基本容器开始，逐步嵌套和修改，以创建复杂界面。结合WWDC2025的最新功能（如Liquid Glass设计系统、空间布局支持和自定义布局协议），SwiftUI的布局能力进一步扩展到3D空间、动态材质和高性能自定义场景。下面我将从基础到高级逐步讲解，并融入最新特性。\n布局基础原理：声明式与响应式 # 声明式布局：你定义视图的结构和关系，SwiftUI负责实际布局计算。例如，使用容器视图包裹子视图，框架会根据设备方向、动态类型（字体大小）和环境值（如暗黑模式）自动适应。 关键组件： ViewBuilder：允许在闭包中堆叠多个视图，支持条件（if-else）、循环（ForEach）和分组（Group），自动组合成单一视图树。 修饰符（Modifiers）：链式应用到视图上调整布局，如 .padding()（间距）、.frame()（固定尺寸）、.alignmentGuide()（自定义对齐）。 响应式设计：布局使用 @Environment或**@EnvironmentObject**读取全局值，确保跨平台一致（如iOS到visionOS）。最新更新中，响应式还包括对AppleIntelligence 的集成，支持动态内容调整。 示例（基本响应式布局）：swift\nstruct ResponsiveView: View { var body: some View { VStack(alignment: .leading) { Text(\u0026#34;标题\u0026#34;) .font(.title) Text(\u0026#34;内容会根据屏幕自动换行和调整。\u0026#34;) } .padding() .frame(maxWidth: .infinity)// 充满宽度 } } 基本容器视图：线性与叠加布局 # 这些是SwiftUI布局的基石，用于排列子视图。\nVStack：垂直堆叠视图，支持间距和对齐。 示例：VStack(spacing: 10) { Text(\u0026ldquo;上\u0026rdquo;) Text(\u0026ldquo;下\u0026rdquo;) } HStack：水平堆叠，类似 VStack 但横向。\nZStack：叠加视图（Z 轴），用于层叠效果，如背景 + 前景。\n示例：ZStack { Color.blue Text(\u0026ldquo;叠加文本\u0026rdquo;) } 这些容器默认使用子视图的理想尺寸进行布局，并支持**.ignoresSafeArea()**扩展到边缘。最新Liquid Glass设计自动应用于这些容器，提供动态玻璃材质背景，提升视觉深度（如模糊和光照效果）。\n高级容器视图：滚动、网格与导航 # 用于处理复杂内容和交互。\nScrollView：支持垂直/水平滚动，内容超出屏幕时自动启用。 最新：集成 MeshGradient 背景，支持动画渐变。 LazyVStack / LazyHStack：懒加载版本，仅渲染可见子视图，优化性能（适合长列表）。 Grid：二维网格布局，支持行/列定义。 示例：Grid { GridRow { Text(\u0026ldquo;1\u0026rdquo;) Text(\u0026ldquo;2\u0026rdquo;) } GridRow { Text(\u0026ldquo;3\u0026rdquo;) Text(\u0026ldquo;4\u0026rdquo;) } } List和Table：数据驱动布局，List用于简单列表，Table支持多列和排序。 NavigationStack/NavigationSplitView：导航容器，支持栈式或分栏导航。 WWDC2025更新：这些容器自动采用Liquid Glass外观，提升工具栏和侧边栏的透明感和流动性。 示例（滚动网格）：swift\nScrollView { LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))]) { ForEach(0..\u0026lt;20) { i in Text(\u0026#34;项 \\(i)\u0026#34;) .frame(width: 100, height: 100) .background(.blue) } } } （LazyHGrid 和 LazyVGrid 的混合网格示例）\n自定义布局与Layout协议（WWDC2025重点） # SwiftUI的Layout协议允许创建高性能自定义布局系统，类似于UIKit的Auto Layout，但更高效和声明式。协议定义了sizeThatFits（计算尺寸）和placeSubviews（放置子视图）方法，支持缓存和动画。\n为什么用？：处理复杂场景，如Pinterest式瀑布流或自定义排列，而不牺牲性能。 最新增强：与iOS18的Apple Intelligence集成，支持动态布局调整；Liquid Glass 可直接应用于自定义布局。 示例（简单自定义布局）：swift\nstruct CustomLayout: Layout { func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -\u0026gt; CGSize { // 计算总尺寸 return CGSize(width: proposal.width ?? 300, height: 200) } func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) { // 放置子视图 for (index, subview) in subviews.enumerated() { let frame = CGRect(x: CGFloat(index) * 100, y: 0, width: 100, height: 100) subview.place(at: frame.origin, proposal: .unspecified) } } } // 使用 CustomLayout { Text(\u0026#34;A\u0026#34;) Text(\u0026#34;B\u0026#34;) } 空间布局（Spatial Layout）：WWDC2025新功能 # SwiftUI扩展到3D空间，主要针对visionOS，支持volumetric和immersive布局。\n深度对齐（Depth Alignments）：类似于2D的垂直/水平对齐，但添加Z轴控制。 新修饰符： spatialOverlay(alignment:content:)：在同一 3D 空间中叠加视图。 rotation3DLayout：在布局系统中旋转视图。 SpatialContainer：新容器，用于3D排列，支持动画和状态管理。 集成：与 RealityKit 结合，构建3D效果；Liquid Glass在3D中提供流体材质，如玻璃变形动画。 示例（简单 3D 布局）：swift\nSpatialContainer { Text(\u0026#34;前层\u0026#34;) .spatialOverlay(alignment: .depth) { Text(\u0026#34;后层\u0026#34;) } } .rotation3DLayout(.degrees(45), axis: (x: 0, y: 1, z: 0)) Liquid Glass在布局中的应用（WWDC 2025 核心设计系统） # Liquid Glass是一种动态玻璃材质，自动应用于系统容器（如Toolbar、NavigationStack），提供模糊、反射和流动性效果。\n新 API： GlassEffectContainer：组合多个玻璃视图，支持变形动画。 .glassEffect(shape:)：应用于任何视图，创建自定义玻璃控件。 ToolbarSpacer：在工具栏中分组间距。 布局影响：提升深度感和统一性；与网格/栈结合，创建现代界面，如半透明叠加层。 自定义：在自定义布局中使用 .tint() 和 .interactive() 添加语义颜色和交互反馈。 示例：swift\nGlassEffectContainer { Button(\u0026#34;按钮1\u0026#34;) { } .glassEffect(shape: Capsule()) Button(\u0026#34;按钮2\u0026#34;) { } .glassEffect() } 布局最佳实践与性能优化 # 嵌套原则：从小容器到大，避免过度嵌套（用 Group 简化）。\n性能：优先 Lazy 容器；使用 @ViewBuilder 自定义函数复用布局。\n调试：WWDC 2025 引入可视化工具，如 frame 可视化扩展，帮助调试空间布局。\nstepinto.vision\n跨平台：布局自动适应，但用 @Environment(.horizontalSizeClass) 细调。\n","date":"2026-01-04","externalUrl":null,"permalink":"/posts/swiftui-layout-structure-explanation/","section":"文章","summary":"","title":"SwiftUI布局结构详解","type":"posts"},{"content":" SwiftUI简介 # SwiftUI是Apple于2019年WWDC推出的声明式用户界面框架，用于构建 iOS、macOS、watchOS、tvOS和visionOS等Apple平台的应用界面。它完全基于Swift语言，让开发者用更少、更简洁的代码描述“界面应该是什么样子”，框架自动处理布局、更新和动画等细节。\n主要特点 # 声明式编程：你描述最终 UI 状态（“是什么”），而非命令式步骤（“怎么做”）。 实时预览：在Xcode中即时看到界面变化，无需反复编译运行。 跨平台一致：同一套代码可在多个Apple设备上运行，自适应不同屏幕尺寸。 数据驱动：界面自动响应数据变化，减少手动刷新代码。 性能优秀：直接基于Metal渲染，效率高。 截至2026年1月，SwiftUI已非常成熟，支持从iOS13+开始的所有系统，并在最新Xcode（支持iOS18+、visionOS 等）中引入了更多高级特性，如增强的3D空间布局、富文本编辑、自定义控件等，已成为Apple 官方推荐的新App开发首选框架。\nSwift和SwiftUI的相互关系 # Swift和SwiftUI是Apple生态中紧密相关的两个核心技术，但它们本质上扮演不同的角色：\nSwiftUI依赖于Swift：你必须使用Swift语言来编写SwiftUI代码。SwiftUI充分利用了Swift 的高级特性（如@state、Property Wrapper、函数构建器等），这些特性甚至部分是为 SwiftUI “量身定制”的。 Swift不依赖SwiftUI：你可以用Swift编写非UI代码（如命令行工具、后端服务），或结合其他UI框架（如传统的 UIKit）。 开发AppleApp时，通常是“用 Swift 编写代码，来控制和驱动 SwiftUI构建界面”。简单比喻：Swift 是“告诉电脑做什么的语言”，SwiftUI 是“知道怎么画按钮、文本、列表等的工具包”。 SwiftUI入门指南 # 1.环境搭建 # 推荐：Mac电脑+最新Xcode（从AppStore下载，支持SwiftUI实时预览Canvas）。 最低要求：Xcode11+（但建议最新版以获得最佳体验）。 创建项目：在Xcode中选“App”模板，Interface选SwiftUI，LifeCycle选SwiftUI App。 2.第一个程序：Hello World # 创建一个新SwiftUI项目，Xcode会自动生成以下代码：swift\nimport SwiftUI struct ContentView: View { var body: some View { Text(\u0026#34;Hello, World!\u0026#34;) .padding() } } #Preview { ContentView() } struct ContentView: View：定义一个视图的结构体。 body：返回视图内容，使用声明式语法堆叠组件。 #Preview：实时预览宏（新版 Xcode 支持）。 运行后，你会看到一个简单的 “Hello, World!” 文本。\n3. 基础语法示例 # 基本视图组件：swift VStack {// 垂直堆叠 Text(\u0026#34;欢迎使用 SwiftUI\u0026#34;) .font(.title) .foregroundColor(.blue) Image(systemName: \u0026#34;heart.fill\u0026#34;) .foregroundColor(.red) Button(\u0026#34;点击我\u0026#34;) { print(\u0026#34;按钮被点击\u0026#34;) } } .padding() 状态管理(@Stata)：数据变化时自动更新界面。swift @State private var count = 0 var body: some View { VStack { Text(\u0026#34;计数: \\(count)\u0026#34;) Button(\u0026#34;加 1\u0026#34;) { count += 1 } } } 常用布局容器： VStack：垂直\nHStack：水平\nZStack：叠加\nSpacer()：占位推开\npadding()、frame()：调整间距和尺寸\n导航和列表：swift NavigationStack { List { NavigationLink(\u0026#34;去详情页\u0026#34;) { Text(\u0026#34;这里是详情\u0026#34;) } } .navigationTitle(\u0026#34;列表\u0026#34;) } 实时预览：在代码旁按 Resume 即可看到 Canvas 预览，支持多设备模拟。 4. 学习资源推荐（中文优先） # Fucking SwiftUI：https://goswiftui.com/ （中文手册、教程、示例，非常全面） Apple 官方互动教程：https://developer.apple.com/tutorials/swiftui （英文，但有交互式代码；推荐结合翻译） SwiftUI 中文教程合集：https://github.com/WillieWangWei/SwiftUI-Tutorials （官方教程翻译 + 代码） SwiftUI 示例项目：https://github.com/jaywcjlove/swiftui-example （大量技巧和实际案例） 菜鸟教程/简书等：搜索 “SwiftUI 入门” 有很多博客。 视频：Bilibili 搜索 “SwiftUI 教程 2025” 或 “Hacking with SwiftUI” 中文字幕版。 SwiftUI学习曲线比UIKit友好得多，尤其是如果你已掌握Swift基础。从官方教程或一个小项目（如Todo List App）开始实践，就能快速上手。建议多用Canvas预览实验，边改代码边看效果。\n","date":"2026-01-04","externalUrl":null,"permalink":"/posts/swiftui-getstarted-guide/","section":"文章","summary":"","title":"SwiftUI入门指南","type":"posts"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/xcode/","section":"标签","summary":"","title":"Xcode","type":"tags"},{"content":" Xcode快捷键概述 # Xcode 提供了丰富的键盘快捷键，以提升开发效率。这些快捷键基于 macOS 系统（Command 为 ⌘，Option 为 ⌥，Control 为 ⌃，Shift 为 ⇧）。以下是按类别整理的常用快捷键列表，来源于 Apple 文档和开发者社区总结（如 Medium、Reddit 和 Stack Overflow）。我优先列出官方标准快捷键，并标注最常用的一些（基于开发者反馈，如构建、运行和导航类最受欢迎）。\n最常用快捷键 # ⌘ + R：运行项目（Run）\n⌘ + B：构建项目（Build）\n⇧ + ⌘ + O：快速打开文件（Open Quickly）\n⌘ + F：查找（Find）\n⌃ + Space：代码补全（Code Completion）\n⌃ + 空格： 代码补全（Code Completion）\n⌘ + U：运行测试（Test）\n⌘ + .：停止构建/运行（Stop）\n⌘ + D：复制当前行（Duplicate Line）\n⌘ + /：注释/取消注释行或块（Comment）\n⇧ + ⌘ + K：清理构建文件夹（Clean Build Folder）\n完整快捷键列表 # 文件操作(File Operations) # 快捷键 描述 ⌘ + N 新建文件 ⇧ + ⌘ + N 新建项目 ⌘ + O 打开\u0026hellip; ⇧ + ⌘ + O 快速打开 (Open Quickly) ⌘ + S 保存 ⇧ + ⌘ + S 另存为\u0026hellip; ⌘ + W 关闭当前标签页或窗口 ⌥ + ⌘ + W 关闭其他所有标签页 导航(Navigation) # 快捷键 描述 ⌘ + / 注释/取消注释选中的代码行 ⌥ + ⌘ + / 添加文档注释 ⌃ + I 重新缩进选中的代码 ⌘ + [ 左移代码块 ⌘ + ] 右移代码块 ⌥ + ←/→ 按词移动光标 ⌘ + ←/→ 移动光标至行首/行尾 ⌥ + 拖动 多光标编辑 ⌘ + F 在当前文件中查找 ⇧ + ⌘ + F 在整个项目中查找 ⌥ + ⌘ + F 查找并替换 ⌃ + ⌘ + E 在作用域内编辑所有匹配项 F6 补全代码 Esc 显示代码补全建议 构建、运行与调试(Build, Run \u0026amp; Debug) # 快捷键 描述 ⌘ + R 构建并运行当前项目 ⌘ + B 构建当前项目 ⌘ + . 停止运行或构建 ⇧ + ⌘ + K 清理构建文件夹 (Clean Build Folder) ⌘ + U 运行单元测试 ⌘ + \\ 设置/取消断点 ⌥ + ⌘ + \\ 启用/禁用所有断点 F6 单步执行 (Step Over) F7 单步进入 (Step Into) F8 单步跳出 (Step Out) ⌃ + ⌘ + Y 继续执行 SwiftUI与界面开发 # 快捷键 描述 ⌥ + ⌘ + P 恢复/刷新SwiftUI预览 ⌥ + ⌘ + Enter 显示/隐藏SwiftUI预览画布 ⇧ + ⌥ + ⌘ + ← 折叠所有代码块 ⇧ + ⌥ + ⌘ + → 展开所有代码块 ","date":"2026-01-04","externalUrl":null,"permalink":"/posts/xcode-keyboard-shortcut/","section":"文章","summary":"","title":"Xcode快捷键大全","type":"posts"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/","section":"标签","summary":"","title":"标签","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/%E5%B9%B6%E5%8F%91/","section":"标签","summary":"","title":"并发","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/%E5%B8%83%E5%B1%80/","section":"标签","summary":"","title":"布局","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/categories/","section":"分类","summary":"","title":"分类","type":"categories"},{"content":"欢迎来到文森的科技小站！这里提供浅显易懂的技术教程，包含前端应用和后端开发，以及移动端应用开发；这里传递最新的科技资讯，重点关注人工智能（AI）、区块链与元宇宙的发展；这里分享最潮的科技产品，包括流媒体、VR眼镜、Apple产品等。\n","date":"2026-01-04","externalUrl":null,"permalink":"/","section":"欢迎来到文森的科技小站! 🎉","summary":"","title":"欢迎来到文森的科技小站! 🎉","type":"page"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/categories/tutorial/","section":"分类","summary":"","title":"技术教程","type":"categories"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/","section":"标签","summary":"","title":"快捷键","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/tags/%E5%85%A5%E9%97%A8/","section":"标签","summary":"","title":"入门","type":"tags"},{"content":"","date":"2026-01-04","externalUrl":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":" Swift 编程语言简介 # Swift 是由 Apple 公司于 2014 年推出的现代编程语言，主要用于开发 iOS、macOS、watchOS、tvOS 和 visionOS 等 Apple 平台的应用。它是一种开源、通用、高性能的编译型语言，结合了 C 和 Objective-C 的优点，同时摒弃了旧语言的一些复杂性和兼容性约束。\n主要特点 # 安全：内置类型安全、可选类型（Optionals）避免空指针异常、内存自动管理（ARC），编译时检查数据竞争。 快速：编译为原生代码，性能接近 C++，支持向量化和优化。 表达力强：语法简洁现代，支持函数式编程、泛型、协议导向编程、闭包等。 交互性好：支持 Playground（代码预览），实时查看运行结果，非常适合学习和实验。 跨平台：不仅限于 Apple 生态，还支持 Linux、Windows 和服务器端开发（如 Vapor 框架）。 开源：社区活跃，可与其他语言（如 C++、Java）互操作。 截至 2026 年 1 月，Swift 的最新稳定版本为 Swift 6.2（2025 年 9 月发布），重点提升了并发性能、工具链和跨平台支持。\nSwift 入门指南 # 1. 环境搭建 # Mac 用户（推荐）：下载最新 Xcode（从 App Store 获取），它内置 Swift 编译器和 Playground。 其他平台：从官网 https://www.swift.org/download/ 下载 Swift 工具链，支持 Windows、Linux。 2. 第一个程序：Hello World # 在 Playground 或 .swift 文件中编写：\nprint(\u0026#34;Hello, World!\u0026#34;) 运行后即输出 Hello, World!。\n3. 基础语法示例 # 变量和常量：swift\nvar variable = 10// 可变变量，类型推断为 Int let constant = 3.14// 常量，不可修改 variable = 20// OK// constant = 4.0 // 错误！ 基本类型：swift\nlet name: String = \u0026#34;Swift\u0026#34;// 字符串 let age: Int = 10 let height: Double = 1.75 let isTrue: Bool = true 可选类型（Optionals）：处理可能为空的值。swift\nvar optionalString: String? = \u0026#34;Hello\u0026#34; print(optionalString ?? \u0026#34;默认值\u0026#34;)// 如果为空，输出默认值 if let value = optionalString { print(value)// 安全解包 } 控制流：swift\nfor i in 1...5 { print(i) } if age \u0026gt; 18 { print(\u0026#34;成人\u0026#34;) } else { print(\u0026#34;未成年\u0026#34;) } 函数：swift\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } print(greet(name: \u0026#34;Grok\u0026#34;)) 集合：swift\nvar array = [1, 2, 3]// 数组 var dict = [\u0026#34;name\u0026#34;: \u0026#34;Swift\u0026#34;, \u0026#34;year\u0026#34;: 2014]// 字典 4. 学习资源推荐（中文优先） # 官方文档：《The Swift Programming Language》中文版（同步更新至最新版本）：https://cnswift.org/ 菜鸟教程：https://www.runoob.com/swift/swift-tutorial.html （简单易懂，带示例） Swift.org 官网：https://www.swift.org/getting-started/ （英文，但有 A Swift Tour 快速导览） Apple 开发者教程：https://developer.apple.com/tutorials/develop-in-swift （结合 SwiftUI 开发 App） 其他：Hacking with Swift（免费教程）、W3Schools Swift 教程。 认识和运用三大工具 # project、playground、command LINE tool # 简单来说，这三者是为不同开发需求和场景设计的工具：\nProject(项目): 是最核心、最完整的开发模式，用于创建可以发布到App Store的正式应用程序。 Playground(游乐场): 是一个轻量级的、用于快速学习、实验和原型设计的交互式环境。 Command Line Tool(命令行工具): 是用于开发没有图形用户界面、在终端中运行的程序。 初学者可以从Playground开始，逐步了解和掌握swift基本语法，就能快速上手。Swift学习曲线友好，如果你有其他语言基础（如Python或Java），上手更快。建议边学边写小项目，比如一个简单的命令行工具或iOS App。\n","date":"2026-01-03","externalUrl":null,"permalink":"/posts/swift-get-start/","section":"文章","summary":"","title":"Swift编程入门","type":"posts"},{"content":"","date":"2026-01-03","externalUrl":null,"permalink":"/tags/%E7%BC%96%E7%A8%8B/","section":"标签","summary":"","title":"编程","type":"tags"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/ai/","section":"标签","summary":"","title":"AI","type":"tags"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/google/","section":"标签","summary":"","title":"Google","type":"tags"},{"content":" Google：2025年12月 AI 更新要点汇总 # 快速概览 # 12 月的主题是把前沿智能从实验室带到日常，重点包括：更快的模型（Gemini 3 Flash）、在 Gemini 应用中增加 AI 验证工具、改进语音与实时翻译、实验性浏览工具（GenTabs / Disco）、面向开发者的 Deep Research 能力开放，以及购物、搜索与回顾类产品的相关扩展。\n详细更新（按主题） # 1) Gemini 3 Flash：极速的前沿智能 # 简介：发布了 Gemini 3 Flash，目标是在保留前沿推理能力的同时显著提升响应速度并降低成本。\n推出渠道：作为默认模型逐步在 Gemini 应用和 Search 的 AI Mode 中上线，同时面向开发者（API）、Antigravity（代理开发平台）和企业（Vertex AI）扩展。\n了解详情： Gemini 3 Flash 介绍Gemini 应用中的 FlashSearch 中的 AI Mode 更新\n2) Gemini 应用：视频 AI 验证工具 # 功能概述：在 Gemini 应用中加入视频验证功能，用户可上传至多 100 MB 或 90 秒的视频，询问视频是否由 Google AI 生成或编辑。 原理说明：Gemini 分析音频与视频轨道，利用不可感知的 SynthID 水印定位哪些片段包含 AI 生成元素。 试用与了解： 视频验证工具介绍 3) Disco 与 GenTabs：让浏览更高效 # 背景痛点：繁杂的多标签浏览会影响研究与计划效率。 新体验：Google Labs 的 Disco 浏览体验内测 GenTabs 实验，自动综合打开的标签页与聊天历史，生成定制化、交互式的“网页工具”，把分散会话变成可操作的工作平台。 试验链接： GenTabs / Disco 介绍 4) 语音与实时翻译能力升级 # Gemini 音频模型更新：推出 Gemini 2.5 Flash Native Audio，提升对话流畅度、指令响应与复杂流程处理能力，已在 AI Studio、Vertex AI、Gemini Live 与 Search Live 中可用。 Google Translate 实时语音翻译测试：在 Google Translate 应用中开启实时语音翻译公测（70+ 语言），可在耳机中保留原始语调与说话节奏，从而实现更自然的跨语言交流。 详情链接： 音频模型更新Search Live 音频更新Translate 实时翻译 5) Gemini Deep Research：开发者的研究代理能力 # 发布内容：通过 Interactions API 向开发者提供更强的 Gemini Deep Research 能力，便于在应用中嵌入复杂主题导航与结果综合的研究代理。 开源基准：发布了 DeepSearchQA 基准以评估研究型代理在网页任务上的全面性与效果。 开发者案例：展示了面向手机优先的解决方案（如：为视障人士定制的 AI 助手、支持认知障碍人士的工具等）。 链接： Deep Research 代理与 API开发者案例 6) 虚拟试衣：Nano Banana 用自拍也能生成全身图 # 更新点：美国购物者现在可以用简单的自拍（无需全身照）上传，Nano Banana 会生成逼真的全身数字人体形象，再配合服装尺寸选择，查看数十亿商品的试穿效果。 试用介绍： Studio-quality digital try-on (Nano Banana) 7) 在 Search 中扩展 Gemini 3 Pro 与 Nano Banana Pro # 范围扩展：Gemini 3 已在近 120 个国家和地区的 Search AI Mode（英文）中提供，Google AI Pro 和 Ultra 订阅者可在模型下拉菜单中选择 Gemini 3 Pro（Thinking with 3 Pro）以可视化复杂主题；同时在更多地区开放 Nano Banana Pro。 美国用户：在美国对这些 Pro 模型也做了扩展（部分功能对非订阅用户开放），并为 Pro/Ultra 订阅者提供更高的使用限额。 详情链接： Gemini 3 在 Search 中扩展 8) 回顾类功能与内容趋势 # YouTube 年度与个人 Recap：公布 2025 年 YouTube 趋势榜单与首个个人化 Recap（YouTube 20 周年相关回顾）。 YouTube 趋势与 Recap Google Photos 回顾：Photos Recap 回归，增加可隐藏特定人物或照片的控制项，并提供 CapCut 模板与一键分享（包括 WhatsApp）。 Google Photos Recap 2025 Year in Search 2025：总结了 2025 年搜索趋势，指出 AI 促成了更多自然、对话式的查询方式（如“How do I…”、“What’s the deal with…”）。 Year in Search 2025 ","date":"2026-01-02","externalUrl":null,"permalink":"/posts/google-ai-updates-december-2025/","section":"文章","summary":"","title":"Google：2025年12月 AI 更新要点汇总","type":"posts"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/notebooklm/","section":"标签","summary":"","title":"NotebookLM","type":"tags"},{"content":" NotebookLM 完整使用指南（2025） # 概述 # NotebookLM 是 Google 推出的知识型 AI 笔记本（2025 年广泛被认为是最有用的免费 AI 工具之一）。它的两大核心能力：\n把各种类型的资料（文档、网页、PDF、图片、音视频、Google 文档/表格/幻灯片等）聚合到同一个笔记本中，并为你做全文索引与分析； 将这些资料直接生成可视化产出（如幻灯片、信息图、报告），或生成音频/视频摘要，支持更易读/分享的输出格式。 适合场景：项目资料整合、课程/自学资料库、研究总结、企业报告、会议材料汇总等。\n如何建立一个笔记本（Step by Step） # 选择目标（Pick a purpose） 为每个独立目标或项目建一个笔记本（例如：工作项目、课程开发、个人兴趣学习）。 示例：作者为 CUNY 新闻学院一个双语硕士在线项目建立了专用笔记本，也为研究作曲家古斯塔夫·马勒建立过笔记本。 查找并添加来源（Find sources） NotebookLM 提供两个检索选项：Fast Research（快速）与 Deep Research（深入）。 Fast Research：30 秒内给出 ~10 篇相关文档，适合快速、精确的素材收集（可从 Google Drive 或网络抓取）。 Deep Research：更慢但能检索更多来源，适合全面调研。 建议：把查询写得尽可能具体，以获得更相关的结果。下面附有作者的一个简洁查询示例（原始示例链接）： 示例查询文档（原文示例）：https://docs.google.com/document/d/1uLwCqpCY8r2yaYuJlmp1pxNFJMGkw2xSFeXxBXE5PWI/edit?usp=sharing 上传你自己的资料（Add your own materials） 支持类型： Google Docs、Slides、Sheets PDF、图像（含手写笔记照片）、Microsoft Word YouTube 链接、音频/视频文件（系统会提取并使用字幕/转录） 网站 URL（会抓取并提取正文文本） 单个文件或资料上限：可上传到 200 MB，最多可包含 500,000 字（以系统提示为准） 免费与 Pro 帐号区别（简表） # 功能 免费账号 Pro（Google AI Pro，约 $20/月） 最多笔记本数量 100 500 每个笔记本可含来源数量 50 300 Deep Research 每月/每日限制 每月可免费运行 10 次 Deep Research 每日可运行 20 次 Deep Research 多媒体生成限制 可能遇到限制（视具体功能而定） 更高配额，支持更多多媒体产出 学生优惠 美国 18 岁以上学生可申请免费 Pro（需通过认证） — 协作与分享 # 类似 Google Docs 的协作权限模型：可邀请他人作为 Viewer（只读）或 Editor（编辑）。 可以控制展示范围：给协作者完整的源文件与笔记访问，或仅开放搜索/聊天界面。 支持公开发布笔记本，示例公开笔记本： Our World in Data — Trends in health, wealth and happiness： https://notebooklm.google.com/notebook/0d5cd576-2583-4835-8848-a5b7b6a97cea The Atlantic — How to build a life： https://notebooklm.google.com/notebook/750a23df-fd98-4954-b9c4-71f16c3ee937 Shakespeare’s Complete Plays： https://notebooklm.google.com/notebook/19bde485-a9c1-4809-8884-e872b2b67b44 Parenting Advice for the Digital Age： https://notebooklm.google.com/notebook/505ee4b1-ad05-4673-a06b-1ec106c2b940 Earnings Reports for the World’s 50 Biggest Companies： https://notebooklm.google.com/notebook/e4ddc6f8-ada2-4aaa-b9dc-c3ff7c325bf8 Secrets of the Super Agers（Eric Topol）： https://notebooklm.google.com/notebook/780a38ee-d0a6-4fb1-b255-aa03c8d67dce 浏览与查询你的资料 # 上传后，NotebookLM 会自动分析并基于已有来源建议“相关问题”。 例如：上传关于马勒的传记材料后，系统可能会建议像“马勒为何改信天主教？”或“哪些诗集影响了马勒？”等查询。 你可以像和智能助手对话一样问任何问题，也可以用传统的搜索查询关键词。 常见操作与实用技巧 # 提问要具体：比起模糊的“讲讲马勒”，更建议使用“马勒在 1900 年至 1910 年间的主要创作动机有哪些？”之类的精确问题。 优先用 Fast Research 做初始资料采集；需要更全面资料再用 Deep Research。 上传多种格式的源文件（尤其是手写笔记的照片或会议录音）能让笔记本成为更完整的知识库。 利用系统生成的可视化输出（幻灯片、信息图、报告等）快速产出可分享的成果，节省二次整理时间。 推荐工作流示例 # 新建笔记本，设置明确目标（例如：为产品发布准备材料）。 用 Fast Research 搜集 10 个高质量来源，筛掉不相关项。 上传内部文档、会议录音、设计稿截图与关键网页链接。 让 NotebookLM 自动分析并生成“关键问题”清单，用以驱动下一步研究。 生成初版幻灯片或报告，交由团队协作者在线编辑与补充。 根据反馈再次运行 Deep Research，补充薄弱环节的资料。 隐私与注意事项 # 上传第三方资料前，请确认有权分享这些内容（尤其是内部保密文件）。 当你公开发布笔记本时，外部用户将能访问包含的源与总结，注意隐私与版权问题。 小结 # NotebookLM 把多来源资料的收集、索引、分析与可视化整合到一个工作流里，极大降低了从“信息”到“产出”的摩擦。无论是学生、自学者、研究员，还是需要管理项目资料的团队，都能通过 NotebookLM 提高效率并快速把知识变成可分享的产品。\n参考与扩展阅读 # NotebookLM 官方：https://notebooklm.google.com/ ","date":"2026-01-02","externalUrl":null,"permalink":"/posts/notebooklm-complete-guide-2025/","section":"文章","summary":"","title":"NotebookLM 完整使用指南（2025）","type":"posts"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/%E6%9B%B4%E6%96%B0/","section":"标签","summary":"","title":"更新","type":"tags"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/%E6%95%99%E7%A8%8B/","section":"标签","summary":"","title":"教程","type":"tags"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/categories/tech-news/","section":"分类","summary":"","title":"科技资讯","type":"categories"},{"content":"","date":"2026-01-02","externalUrl":null,"permalink":"/tags/%E6%8C%87%E5%8D%97/","section":"标签","summary":"","title":"指南","type":"tags"},{"content":" 5 款你上线 Meta Quest 后必须先安装的应用 # 虚拟现实头显近年成为非常吸引人的娱乐设备。许多人购买了 Meta Quest 3，把它作为首选的游戏和多媒体平台。但合适的应用能把 Quest 从“游戏机”变成私人影院、生产力工具、健身工作室或冥想静修地。下面是根据实测、用户评分与社区推荐筛选出的五款必装应用，每款都附功能亮点、价格与使用建议，帮助你快速上手并扩展 VR 的用途。\n1. Bigscreen Beta — 社交影院与远程桌面 # 官方页面：https://www.meta.com/en-gb/experiences/bigscreen-beta/2497738113633933/\n简介：Bigscreen Beta 可以把你的 Quest 变成多人社交影院或大型虚拟屏幕。你可以邀请朋友进房间，选择场景（营火、黑暗影院等），一起观看电影、节目或 YouTube。它还支持将 Windows PC 的屏幕远程投射到头显，等于是把电脑桌面搬到 VR 中。\n亮点：\n支持最多约 12 人的社交房间，共同观影与聊天。 内置 Cloud Browser（可在 VR 中直接浏览网页与播放媒体）。 远程桌面流式传输：可以在虚拟大屏上玩 PC 游戏或播放本地 3D/高码率视频。 注意事项：\n部分用户反映存在音频问题、视频延迟或黑屏等 bug。体验视网络与设备稳定性而定。 Cloud Browser 在 2 小时试用后需要订阅，价格约为 $9.99/月（以商店为准）。 适合人群：想要多人观影、VR 社交或把 PC 屏幕带入 VR 的用户。\n2. Steam Link — 把你的 Steam 库串流到 Quest # 官方页面：https://www.meta.com/en-gb/experiences/steam-link/5841245619310585/\n简介：Steam Link 允许你将整个平台的 PC 游戏（不仅限 VR 游戏）串流到 Quest。Valve 官方已发布适配 Quest 的版本，配合 PC 上的 Steam 和 SteamVR 使用，可以把 PC 的运算能力用于运行大型游戏，Quest 仅做画面与输入的接收端。\n亮点：\n支持将《Half-Life: Alyx》等高品质 VR 游戏由 PC 端渲染并串流到 Quest。 可在虚拟“大屏”模式下直接运行普通非 VR 游戏（类似 Bigscreen 的体验）。 支持手柄或手部追踪作为控制方式。 使用建议与限制：\n要求稳定且高带宽的本地网络（优先 5GHz Wi‑Fi 或有线回传到路由器）。 串流质量受限于 PC 配置与网络延迟，低网速会导致卡顿、丢帧或画质下降。 适合人群：拥有较强 PC、想在 Quest 上玩 PC VR 或把 Steam 游戏搬到 VR 的玩家。\n3. Mondly VR — 沉浸式语言练习 # 官方页面：https://www.meta.com/en-gb/experiences/mondly-practice-languages-in-vr/4214902388537196/\n简介：Mondly 把语言学习带入沉浸式场景，你可以在虚拟酒店、餐厅或车站与虚拟角色对话。内置语音识别与聊天机器人能即时评估发音并给出反馈，支持约 30 种语言。\n亮点：\n真实场景对话练习，强调口语与听力实战能力。 实时语音识别与发音反馈，帮助改善口语流利度。 支持多人模式，与其他玩家一起练习对话。 局限：\n场景会重复使用（同一火车或餐厅场景可能对应不同语言），会降低文化代入感。 反馈多为即时评分，缺乏更细致的发音纠正说明。 适合人群：想在沉浸式环境中练习口语、提高对话自信的初中级学习者。\n4. Mindway — 冥想、睡眠与 ASMR（心理健康类） # 官方页面：https://www.meta.com/en-gb/experiences/mindway-mindfulness-meditation-sleep-asmr/5978805525464490/\n简介：Mindway 是一款面向心理健康的应用，集合短时冥想、ASMR、睡眠辅导以及社群支持（Fireside）等项目。它以短时可执行的练习为主，让忙碌的用户也能随时进行心理调节。\n亮点：\n风景式冥想场景（森林、夜空等），沉浸感强。 短时练习与结构化课程并重，便于培养习惯。 社群支持环节（Fireside）可以进行小组互动式体验。 Quest 3 上支持“自定义冥想”模式，将呼吸练习与现实场景结合。 价格与注意事项：\n完整内容通常需要订阅，约 $5/月 或一次性 $50 解锁（以商店信息为准）。 部分高级课程与睡眠内容被锁在付费墙后。 适合人群：需要借助沉浸式环境管理情绪、睡眠或建立冥想习惯的用户。\n替代项：Tripp（另一款知名的 VR 冥想应用）。\n5. Supernatural — 高强度沉浸式健身 # 官方页面：https://www.meta.com/en-gb/experiences/supernatural-unreal-fitness/1830168170427369/\n简介：Supernatural 将健身与沉浸式场景与节奏音乐结合，用户通过挥拳、下蹲、挥动动作完成训练。课程类型覆盖恢复拉伸、拳击、节奏流（flow）等，并由教练引导。\n亮点：\n将全身运动与名曲、壮观景点（长城、沙漠、月球等）结合，趣味性强。 多种训练类别，既有高强度心肺也有恢复类。 有研究显示该类应用可以提供高强度运动并支持周卡路里目标（相关研究由 Supernatural 委托）。 价格与限制：\n订阅制，约 $99/年（以应用内实际定价为准），价格相对昂贵。 训练需要足够的运动空间，需注意周边物品与安全（避免打到电视等）。 适合人群：喜欢把锻炼变成游戏、愿意为优质 VR 健身内容付费的用户。\n我们如何挑选这些“必装”应用 # 筛选原则简要：\n覆盖面广：选取能展示 VR 多样用途（社交、娱乐、学习、精神健康、健身）的应用。 用户评分与评论：优先考虑 Meta 商店评分 \u0026gt;= 3/5 且用户数多的应用，同时参考 Reddit 与其他用户论坛的反馈。 可用性与趣味性：兼顾实用价值与趣味体验，包含大众熟悉的热门应用与评分优秀的潜力款。 快速安装与使用小贴士 # 网络：使用 5GHz Wi‑Fi，或将 PC 用有线连接到路由器，减少串流延迟（Steam Link、Bigscreen 的远程桌面依赖网络）。 空间：健身类（Supernatural）需保证周围至少留出 1.5–2 米的活动空间，避免碰撞。 订阅管理：注意 Cloud Browser（Bigscreen）、Mindway 与 Supernatural 等应用的订阅或试用到期提醒，避免意外付费。 PC 准备：若要使用 Steam Link，请在 PC 上安装 Steam 与 SteamVR，并确保显卡与 CPU 能满足目标游戏。 音频/视频故障排查：遇到黑屏或声音问题，尝试重启应用、重连路由器或切换到有线回传（PC 端）。 ","date":"2026-01-01","externalUrl":null,"permalink":"/posts/essential-meta-quest-apps/","section":"文章","summary":"","title":"5 款 Meta Quest 必装应用","type":"posts"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/tags/meta/","section":"标签","summary":"","title":"Meta","type":"tags"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/tags/quest3/","section":"标签","summary":"","title":"Quest3","type":"tags"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/tags/steam-frame/","section":"标签","summary":"","title":"Steam Frame","type":"tags"},{"content":" Steam Frame、Apple Vision Pro 与 Meta Quest 3 对比：性能与游戏体验谁更强？ # 快速导读：Valve 新公布的 Steam Frame 主打流式体验并兼容整个 Steam 库；Apple Vision Pro 则以更高分辨率与 AR 能力为主；Meta Quest 3 以亲民价格和独立可玩性领先。下面给出详细规格对比与购买建议。\n一、三款头显一览（主要规格对比） # 项目 Steam Frame (Valve) Apple Vision Pro (M5) Meta Quest 3 处理器 Snapdragon 8 Gen 3 (4 nm, ARM64) Apple M5 Snapdragon XR2 Gen 2 内存 16 GB Unified LPDDR5X 16 GB 8 GB 存储 256GB / 1TB UFS，microSD 扩展 256GB / 512GB / 1TB 512GB 单眼分辨率 2160 × 2160 3660 × 3200 2064 × 2208 刷新率 72–144 Hz（144Hz 实验性） 90 / 96 / 100 / 120 Hz 72 / 90 / 120 Hz 电池 / 使用时间 21.6 Wh (电池容量) 一般使用约 2.5 小时 / 视频播放可达 3 小时 19.44 Wh 视场角 (FOV) 最高约 110° 约 100° 110° 水平 / 96° 垂直 眼动追踪 有 有 无 彩色透视 仅单色透视摄像头 彩色透视，支持 AR/MR 彩色透视，支持 AR/MR 价格 未公布（目标低于 $1000） $3,499 $499.99 注：Steam Frame 预计于 2026 年初发售；Valve 宣称该设备以“流式为主”的体验为核心，并兼容 Steam 平台上 VR 与非 VR 游戏。\n二、哪款更适合玩游戏？ # Steam Frame 的最大优势：兼容整个 Steam 库。 Valve 明确表示 Steam Frame 可访问你 Steam 上的所有游戏（无论是否为原生 VR），这对已有大量 Steam 游戏的玩家是重大利好。 与 Steam 家族其他硬件（如 Steam Deck、Steam Controller）兼容，扩展性强。 Meta Quest 3：更亲民、独立运行、拥有较多原生 VR 游戏。 Quest 系列生态成熟且价格友好，适合预算有限但想直接玩 VR 游戏的用户。 Apple Vision Pro：并非以游戏为核心。 Vision Pro 更注重 AR / 混合现实的生产力与沉浸式体验，虽然硬件显示素质高，但游戏生态相对较小，许多内容并非原生游戏或未针对高频率互动优化。 综上：如果你的首要目标是玩 Steam 库游戏并希望最大兼容性，Steam Frame 更有吸引力；如果你想要低成本、即插即玩的独立 VR，选 Quest 3；如果你追求高分辨率显示与 AR 体验（并且预算充足），可以考虑 Vision Pro，但不一定是最佳游戏主机。\n三、AR 与 VR 的差别（以及三者定位） # VR（虚拟现实）：完全沉浸，通常遮挡真实世界。 AR（增强现实）/ MR（混合现实）：在用户视野中叠加虚拟元素，同时保留对现实世界的感知与交互。 设备定位：\nSteam Frame：偏向纯 VR（目前仅配备单色透视摄像头），但具有前置扩展口，未来可能通过扩展模块支持彩色透视或其他功能。 Apple Vision Pro：定位为 AR / MR 设备，同时支持 VR 内容（彩色透视与高分辨率为其强项）。 Meta Quest 3：介于两者之间，支持彩色透视以实现混合现实体验，但更侧重于独立 VR 游戏与轻量 AR 功能。 四、价格与性价比（谁最实惠？） # Meta Quest 3：约 $499 —— 最容易入手，性价比最高，适合大众玩家。 Steam Frame：目标价低于 $1,000（Valve 尚未最终定价）——如果能保持在 1k 美元以内，并且能完整支持 Steam 库，将具备很高的吸引力。 Apple Vision Pro：$3,499 —— 属于高端/旗舰级产品，适合追求顶级显示、设计与 AR 体验的用户，但对纯游戏需求的玩家来说成本颇高。 五、各机型优缺点速览 # Steam Frame 优点：原生兼容 Steam 大库、16GB 统一内存、扩展性好、目标价格比 Vision Pro 低。 缺点：目前仅单色透视，定位偏纯 VR，尚未公布最终售价与部分细节。 Apple Vision Pro 优点：超高分辨率（单眼 3660×3200）、成熟的 AR/MR 能力、M5 芯片性能强劲、精致做工与生态整合。 缺点：价格极高、游戏库有限、续航偏短（一般使用约 2.5 小时）。 Meta Quest 3 优点：价格亲民、独立运行、支持彩色透视与混合现实、生态丰富（众多原生 VR 游戏）。 缺点：硬件规格低于 Steam Frame 与 Vision Pro（如内存、部分分辨率指标）。 六、购买建议（按需求） # 如果你有大量 Steam 游戏并希望在头显上直接访问与游玩：优先考虑 Steam Frame（尤其关注 Valve 对兼容性的承诺）。 如果你预算有限且想要稳定、独立的 VR 游戏体验：Meta Quest 3 更合适。 如果你追求顶级显示效果、AR/MR 整合与高端体验且不介意高价：Apple Vision Pro 是定位正确的选择。 七、时间线与后续 # Steam Frame：Valve 计划 2026 年初上市，具体售价待公布。 Vision Pro：已于 2025 年获得 M5 升级并上市（但仍属高端价位）。 Quest 3：已在市面销售，作为较为成熟的独立 VR 选项存在。 小结：三款设备各有侧重——Steam Frame 面向 Steam 玩家、Quest 3 面向大众入门 VR、Vision Pro 面向高端 AR/MR 应用。最终选择应以你的使用场景（重度游戏/混合现实/预算）为准。\n","date":"2026-01-01","externalUrl":null,"permalink":"/posts/steam-frame-vs-vision-pro-vs-quest-3-gaming-specs/","section":"文章","summary":"","title":"Steam Frame、Apple Vision Pro 与 Meta Quest 3 对比","type":"posts"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/tags/vision-pro/","section":"标签","summary":"","title":"Vision Pro","type":"tags"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/tags/vr/","section":"标签","summary":"","title":"Vr","type":"tags"},{"content":"","date":"2026-01-01","externalUrl":null,"permalink":"/categories/tech-gadgets/","section":"分类","summary":"","title":"科技潮品","type":"categories"},{"content":"","date":"2025-12-30","externalUrl":null,"permalink":"/tags/2025/","section":"标签","summary":"","title":"2025","type":"tags"},{"content":" 2025 年最具影响力的开源项目 # GitHub Universe 2025 的 Open Source Zone 汇聚了许多令人振奋的开源项目——它们展示了创意、工程实力与“我得试试这个”的演示。本篇笔记整理并改写了大会上展示的 12 个优秀项目：介绍要点、起源故事、趣闻与相关链接，便于你快速了解与参与。\n目录\nAppwrite：简化后端 GoReleaser：Go 的发布自动化 Homebrew：macOS 必备包管理器 Ladybird：敢为人先的浏览器 Moondream：小体量视觉 AI Oh My Zsh：为 Shell 加速 OpenCV：计算机视觉核心库 Open Source Project Security Baseline (OSPSB)：提升安全基线 p5.js 与 Processing：创意编程入门 PixiJS：网页 2D 图形引擎 SparkJS：将 Gaussian Splatting 带入 3D 网页 Zulip：可扩展的主题化讨论 Appwrite：简化后端 # 官网：appwrite.io 简介：Appwrite 是一个开源后端即服务（BaaS）平台，提供数据库、认证、存储等 API，帮助 Web 与移动开发者减少样板代码、快速交付。 起源：由 Eldad Fux 在 2019 年以副业项目开始，迅速成长为 GitHub 上增长最快的开发者平台之一，拥有超过 50,000 ⭐ 与数百名贡献者。 小贴士：如果你希望在短时间里把后端功能接入前端应用，Appwrite 是一个值得尝试的开源选项。\nGoReleaser：Go 项目的发布自动化 # 官网：goreleaser.com 简介：自动化打包、发布与分发 Go 项目的工具，适合想把精力放在开发而非发布流程的维护者。 起源故事：2015 年从一个简单的 release.sh 脚本开始，随后 @caarlos0 用 Go 重写并加入 YAML 配置，如今已有 15,000+ ⭐ 并被多个团队付费使用（包括 GitHub 自身的若干工具）。 有趣点：Go 的 Gopher 文化有大量创意周边，GoReleaser 的 logo 也被广泛喜爱——社区视觉文化很重要。\nHomebrew：macOS 的包管理器 # 官网：brew.sh 简介：Homebrew 是 macOS 的事实标准包管理器，简化软件安装、更新与管理流程，被开发者与工程师广泛使用。 社群声音：“在 GitHub Universe 与用户和维护者面对面交流，让团队重新充能。” — Issy Long（Homebrew 资深工程师与维护者） 维护者们现场解答用户问题，是线下活动中最暖心的部分：交流直接、反馈及时。\nLadybird：为勇敢者打造的浏览器 # 官网：ladybird.org 简介：Ladybird 是一个从零开始构建的开源浏览器，注重性能、安全与隐私。从最初的 HTML 查看器演化为完整浏览器，引来快速增长的社区支持。 社区规模：项目起源于 SerenityOS，现已吸引上千位贡献者。 小提示：关注 Ladybird 的月度更新可了解浏览器核心组件的迭代（如 WebGL、变量字体支持与性能改进）。\nMoondream：小体量、强功能的视觉 AI # 官网：moondream.ai 简介：开源视觉语言模型，体积仅约 1 GB，可在 CPU 环境、笔记本或边缘设备上运行，无需 GPU。支持图像描述、目标检测、注视跟踪、文档读取等自然语言接口。 影响力：超过 600 万次下载、成千上万颗 ⭐，跨医疗、机器人等行业被采用。 建议：如果你需要在受限设备上加入视觉理解能力，Moondream 是低成本、高可用的选择。\nOh My Zsh：为 Shell 加料 # 官网：ohmyz.sh 简介：社区驱动的 Zsh 配置框架，提供数百个插件与主题，让命令行更强、更美观。 起源：2009 年由 Robby Russell 周末启动的项目，如今已成为管理 Zsh 配置的主要开源框架之一。 社区花心思自定义 prompt（提示符），许多维护者分享他们的配置与美化技巧，值得研究与借鉴。\nOpenCV：计算机视觉的基石 # 官网：opencv.org 简介：最广泛使用的开源计算机视觉库，覆盖图像处理、视频分析、机器视觉与研究原型开发。 起源：1999 年由 Intel 发起的研究项目，现已构建起庞大的用户与贡献者生态，应用场景从自动驾驶到社交滤镜均有体现。 提示：OpenCV 适合作为跨平台的视觉处理工具箱，学习曲线平缓且资料丰富。\nOpen Source Project Security Baseline (OSPSB)：提升安全基线 # 官网：baseline.openssf.org 简介：由 OpenSSF 发起的实践性安全基线，为维护者提供可执行、现实的最小安全要求与自评工具，帮助项目提升韧性。 大会反馈：在 Universe 2025 上，许多维护者表示 Baseline 帮他们在纷繁复杂的威胁环境中找到明确、可行的改进方向。 引用：\u0026ldquo;开源的韧性与可持续性是维护者与用户的共同责任。Baseline 不只告诉消费者为什么信任你的项目，也指明了他们可以如何参与改进安全。\u0026rdquo; — Xavier René-Corail，GitHub 安全研究高级总监\np5.js 与 Processing：创意编程的入门工具 # p5.js 官网：p5js.org Processing 官网：processing.org 简介：两者都致力于让艺术家、教育者与初学者通过代码进行创意表达。p5.js 是 JavaScript 版、适合网页交互；Processing 更侧重教学与装置艺术。 适合人群：想把视觉艺术、互动装置或课堂教学与编程结合的创作者与教师。\nPixiJS：网页上的 2D 图形引擎 # 官网：pixijs.com 简介：基于 WebGL/WebGPU 的高性能 2D 渲染引擎，支持自定义 shader、高级文本渲染、多点触控与可访问性。已被多家品牌与游戏采用。 记忆点：拥有 46,000+ ⭐，适合需要在浏览器中实现复杂动画、游戏或大规模可视化的项目。 示例项目：曾用于将博物馆开源艺术作品做成互动动画（参见给定链接示例）。\nSparkJS：把 Gaussian Splatting 带入 3D 网页 # 仓库：sparkjsdev/spark 简介：为 THREE.js 提供高效的 3D Gaussian Splatting 渲染器，支持正确排序、动画与多种 splat 格式（如 .PLY、.SPZ、.KSPLAT）。 什么是 Gaussian Splatting：一种用大量半透明椭球（“splats”）代替多边形网格的渲染技术，能在保持细节的同时实现实时性能。 适用场景：需要在网页上呈现高质量、细腻 3D 场景但又受限于设备性能时非常合适。\nZulip：可扩展的主题化讨论 # 官网：zulip.com 简介：以主题（topic）为中心的团队聊天平台，解决聊天失序问题，便于大型分布式团队进行有条理的讨论。 起源与发展：2012 年由初创团队开发、2014 年被 Dropbox 收购并于 2015 年开源；现有 1,500+ 贡献者，在社区、课堂与企业中广泛使用。 现场花絮：Zulip 的维护者在展位上与参会者讨论如何通过线程化话题提升长期知识保留。\n","date":"2025-12-30","externalUrl":null,"permalink":"/posts/most-influential-open-source-projects-2025/","section":"文章","summary":"","title":"2025 年GitHub上最具影响力的开源项目","type":"posts"},{"content":"","date":"2025-12-30","externalUrl":null,"permalink":"/tags/github/","section":"标签","summary":"","title":"Github","type":"tags"},{"content":"","date":"2025-12-30","externalUrl":null,"permalink":"/tags/open-source/","section":"标签","summary":"","title":"Open Source","type":"tags"},{"content":"","date":"2025-12-06","externalUrl":null,"permalink":"/tags/sonicjs/","section":"标签","summary":"","title":"SonicJs","type":"tags"},{"content":"","date":"2025-12-06","externalUrl":null,"permalink":"/tags/%E5%90%8E%E7%AB%AF/","section":"标签","summary":"","title":"后端","type":"tags"},{"content":" SonicJS # 一个现代的、TypeScript优先的无头CMS，专为Cloudflare边缘平台和Hono.js构建。\n📦 快速开始：\nnpx create-sonicjs@latest my-app ⚠️ 注意： 本仓库用于开发SonicJS核心包。构建应用请使用上述命令创建新项目。\n🚀 主要特性 # 核心平台 # ⚡ 边缘优先：专为Cloudflare Workers设计，全球低延迟 🔧 开发者友好：配置优先，TypeScript优先策略 🤖 AI友好：结构化代码，支持AI辅助开发 🔌 插件系统：无需修改核心即可扩展 📱 现代技术栈：Hono.js、TypeScript、D1数据库、R2存储、HTMX 🚀 高速轻量：针对边缘计算优化 高级内容管理（阶段5） # 📝 集成TinyMCE的富文本编辑器，支持自定义工具栏 🎛️ 动态字段类型（文本、数字、日期、布尔、选择、媒体） 📚 完整的内容版本控制及恢复功能 ⏰ 内容发布/撤销时间调度 🔄 支持基于角色权限的工作流（草稿→审核→发布→归档） 💾 自动保存（每30秒） 👁️ 实时内容预览 📋 内容一键复制与模板支持 🛡️ XSS防护，输入验证和HTML转义 🛠 技术栈 # 核心框架 # Hono.js：超快的Cloudflare Workers Web框架 TypeScript：严格类型安全 HTMX：增强HTML动态交互 Cloudflare服务 # D1：边缘SQLite数据库 R2：媒体对象存储 Workers：无服务器计算 KV：缓存键值存储 Images API：图片优化与转换 开发工具 # Vitest：快速单元测试 Playwright：端到端测试 Wrangler：本地开发与部署 Drizzle ORM：类型安全数据库查询 🏁 快速开始 # 快速部署SonicJS流程 # # 1.本地创建新项目 npx create-sonicjs@latest my-app # 2.进入项目目录 cd my-app # 3.登录cloudflare npx wrangler login # 4.创建 D1 数据库（记录下database_id)： npx wrangler d1 create my-sonicjs-db # 5.创建 R2 存储桶（用于存放上传的图片/文件）： npx wrangler r2 bucket create my-sonicjs-media # 修改配置文件 (wrangler.toml) [[d1_databases]] binding = \u0026#34;DB\u0026#34; database_name = \u0026#34;my-sonicjs-db\u0026#34; # 你创建的名字 database_id = \u0026#34;xxxx-xxxx-xxxx\u0026#34; # 刚才创建后生成的 ID [[r2_buckets]] binding = \u0026#34;MEDIA_BUCKET\u0026#34; bucket_name = \u0026#34;my-sonicjs-media\u0026#34; # 你创建的桶名字 **# 核心步骤：执行数据库迁移（初始化表结构）** npm run db:migrate # 启动开发服务器 npm run dev # 访问 \u0026lt;http://localhost:8787\u0026gt; **# 核心步骤：同步到远程数据库D1** npm run db:migrate -- --remote # 部署到cloudflare npm run deploy 备注：如遇到无法新增和保存内容，请执行以下步骤\n# 初始化本地数据库 # 这一步会创建本地的 .wrangler 文件夹并生成 SQLite 数据库文件，DB必须是配置文件绑定的数据库名 npx wrangler d1 migrations apply DB --local # 如果遇到无法新增和保存内容，可以用以下命令手动补全缺失的字段 npx wrangler d1 execute DB --local --command=\u0026#34;ALTER TABLE content ADD COLUMN created_by TEXT;\u0026#34; npx wrangler d1 execute DB --local --command=\u0026#34;ALTER TABLE content ADD COLUMN updated_by TEXT;\u0026#34; # 同步数据库表结构（核心步骤） npx wrangler d1 migrations apply DB --remote # 线上环境补齐 npx wrangler d1 execute DB --remote --command=\u0026#34;ALTER TABLE content ADD COLUMN created_by TEXT;\u0026#34; npx wrangler d1 execute DB --remote --command=\u0026#34;ALTER TABLE content ADD COLUMN updated_by TEXT;\u0026#34; # 再部署 npm run deploy 默认包含：\nSonicJS CMS预配置 数据库迁移准备 示例内容集合 管理界面 /admin 即刻部署至Cloudflare 数据库命令集 # 本地数据库命令 (Local Development) # 这些命令操作的是你电脑本地 .wrangler 文件夹下的 SQLite 数据库。\n命令 用途 备注 npx wrangler d1 migrations apply DB --local 应用迁移 将代码中的表结构改动同步到本地数据库。 npx wrangler d1 execute DB --local --command=\u0026quot;...\u0026quot; 执行 SQL 直接运行 SQL 语句，如之前补齐字段的操作。 npx wrangler d1 execute DB --local --file=./seed.sql 导入数据 运行指定的 SQL 文件来初始化测试数据。 npm run db:reset 重置数据库 (SonicJS 特有脚本) 通常用于清空并重新初始化本地库。 npx wrangler d1 migrations list DB --local 查看状态 查看本地有哪些迁移脚本已运行。 远程数据库命令 (Production/Cloudflare) # 当你准备将网站发布到线上时，需要操作 Cloudflare 云端的 D1 实例。\n命令 用途 备注 npx wrangler d1 create \u0026lt;db-name\u0026gt; 创建数据库 在 Cloudflare 控制台创建一个新的 D1 实例。 npx wrangler d1 migrations apply DB --remote 同步表结构 发布必做！ 将表结构同步到云端数据库。 npx wrangler d1 execute DB --remote --command=\u0026quot;...\u0026quot; 远程 SQL 直接修改线上数据（慎用）。 npx wrangler d1 export DB --remote --output=db.sql 导出数据 将线上数据备份到本地。 数据库迁移 # 迁移文件位于 packages/core/migrations/，测试应用通过npm工作区符号链接引用。\n# 查询迁移状态（本地） wrangler d1 migrations list DB --local # 应用本地迁移 wrangler d1 migrations apply DB --local # 应用生产迁移 wrangler d1 migrations apply DB --remote 迁移开发建议：\n在 packages/core/migrations/ 新建SQL文件，命名格式如 027_add_user_preferences.sql 编写幂等SQL（CREATE TABLE IF NOT EXISTS等） 生成迁移包：npm run generate:migrations 重新构建核心包：npm run build:core 应用到测试数据库 📁 项目结构 # sonicjs-ai/ ├── packages/ │ ├── core/ # 主CMS包，发布为 @sonicjs-cms/core │ │ ├── src/ │ │ │ ├── routes/ # 路由处理（管理、API、认证） │ │ │ ├── templates/ # HTML模板和组件 │ │ │ ├── middleware/# 认证与中间件 │ │ │ ├── utils/ # 工具函数 │ │ │ └── db/ # 数据库模式与迁移 │ │ └── package.json │ ├── templates/ # 模板系统包 │ └── scripts/ # 构建脚本 ├── my-sonicjs-app/ # 测试应用（git忽略） ├── www/ # 网站营销页 ├── tests/e2e/ # 端到端测试 └── drizzle/ # 数据库迁移管理 注意：\n本仓库非应用项目，专注于核心包开发。 应用代码在 packages/core/ 或测试应用中。 🔧 内容管理 # 创建集合 # 通过管理界面或数据库定义动态字段集合。示例SQL：\nINSERT INTO collections (id, name, display_name, description, schema) VALUES ( \u0026#39;blog-posts\u0026#39;, \u0026#39;blog_posts\u0026#39;, \u0026#39;博客文章\u0026#39;, \u0026#39;文章内容集合\u0026#39;, \u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;object\u0026#34;,\u0026#34;properties\u0026#34;:{\u0026#34;title\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;required\u0026#34;:true}}}\u0026#39; ); INSERT INTO content_fields (collection_id, field_name, field_type, field_label, field_options) VALUES (\u0026#39;blog-posts\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;标题\u0026#39;, \u0026#39;{\u0026#34;maxLength\u0026#34;: 200, \u0026#34;required\u0026#34;: true}\u0026#39;), (\u0026#39;blog-posts\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;richtext\u0026#39;, \u0026#39;内容\u0026#39;, \u0026#39;{\u0026#34;toolbar\u0026#34;: \u0026#34;full\u0026#34;, \u0026#34;height\u0026#34;: 400}\u0026#39;), (\u0026#39;blog-posts\u0026#39;, \u0026#39;excerpt\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;摘要\u0026#39;, \u0026#39;{\u0026#34;maxLength\u0026#34;: 500, \u0026#34;rows\u0026#34;: 3}\u0026#39;), (\u0026#39;blog-posts\u0026#39;, \u0026#39;featured_image\u0026#39;, \u0026#39;media\u0026#39;, \u0026#39;特色图片\u0026#39;, \u0026#39;{\u0026#34;accept\u0026#34;: \u0026#34;image/*\u0026#34;}\u0026#39;), (\u0026#39;blog-posts\u0026#39;, \u0026#39;publish_date\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;发布日期\u0026#39;, \u0026#39;{\u0026#34;defaultToday\u0026#34;: true}\u0026#39;), (\u0026#39;blog-posts\u0026#39;, \u0026#39;is_featured\u0026#39;, \u0026#39;boolean\u0026#39;, \u0026#39;精选文章\u0026#39;, \u0026#39;{\u0026#34;default\u0026#34;: false}\u0026#39;); 字段类型 # text：单行文本，支持校验 richtext：集成TinyMCE的富文本编辑器 number：数字输入，支持范围限制 boolean：复选框 date：日期选择器 select：单选/多选下拉 media：文件选择及预览 🌐 API接口 # 内容管理 # 方法 路径 描述 GET /admin/content/new?collection=id 创建新内容表单 GET /admin/content/:id/edit 编辑内容表单 POST /admin/content/ 创建内容（含验证） PUT /admin/content/:id 更新内容（含版本控制） DELETE /admin/content/:id 删除内容 高级功能 # 方法 路径 描述 POST /admin/content/preview 发布前预览内容 POST /admin/content/duplicate 复制内容 GET /admin/content/:id/versions 获取版本历史 POST /admin/content/:id/restore/:version 恢复指定版本 GET /admin/content/:id/version/:version/preview 预览历史版本 公共API # 方法 路径 描述 GET /api/content 获取已发布内容（分页） GET /api/collections/:collection/content 获取指定集合内容 GET /api/collections 列出所有集合 🚀 部署 # 环境配置示例 # # wrangler.toml name = \u0026#34;my-sonicjs-app\u0026#34; main = \u0026#34;src/index.ts\u0026#34; compatibility_date = \u0026#34;2024-01-01\u0026#34; [[d1_databases]] binding = \u0026#34;DB\u0026#34; database_name = \u0026#34;my-app-db\u0026#34; database_id = \u0026#34;your-database-id\u0026#34; [[r2_buckets]] binding = \u0026#34;MEDIA_BUCKET\u0026#34; bucket_name = \u0026#34;my-app-media\u0026#34; 🧪 测试 # # 运行单元测试 npm test # 监听模式运行测试 npm run test:watch # 端到端测试 npm run test:e2e # 带UI的端到端测试 npm run test:e2e:ui 🔌 插件开发 # 通过插件扩展SonicJS功能，示例代码：\n// src/plugins/my-plugin/index.ts import { Plugin } from \u0026#39;@sonicjs/core\u0026#39; export default { name: \u0026#39;my-plugin\u0026#39;, hooks: { \u0026#39;content:beforeCreate\u0026#39;: async (content) =\u0026gt; { // 插件逻辑 return content } } } as Plugin ","date":"2025-12-06","externalUrl":null,"permalink":"/posts/sonicjs-modern-typescript-headless-cms/","section":"文章","summary":"","title":"开源后端SonicJS部署指南","type":"posts"},{"content":"","date":"2025-12-05","externalUrl":null,"permalink":"/tags/cms/","section":"标签","summary":"","title":"CMS","type":"tags"},{"content":"","date":"2025-12-05","externalUrl":null,"permalink":"/tags/hugo/","section":"标签","summary":"","title":"Hugo","type":"tags"},{"content":" Hugo 内容适配器（Content adapters） # 内容适配器用于在构建站点时动态创建页面。常用于从远程 JSON/TOML/YAML/XML 等数据源生成页面（新增于 v0.126.0）。\n概览 # 内容适配器是模板类型的一种，但它们位于 content 目录，而不是 layouts。 每个目录（每种语言）最多一个内容适配器，命名为 _content.gotmpl（或带语言后缀的 _content.\u0026lt;lang\u0026gt;.gotmpl）。 内容适配器创建的页面的逻辑路径（logical path）相对于内容适配器所在目录。 示例目录结构：\ncontent/ ├── articles/ │ ├── _index.md │ ├── article-1.md │ └── article-2.md ├── books/ │ ├── _content.gotmpl \u0026lt;-- content adapter │ └── _index.md └── films/ ├── _content.gotmpl \u0026lt;-- content adapter └── _index.md 内容适配器使用与 layouts 模板相同的语法和函数，可在模板内调用下列方法来创建页面和资源。\n注意：EnableAllDimensions 方法为 v0.153.0 新增。\n方法（Methods） # 在内容适配器中常用的方法：AddPage、AddResource、Site、Store、EnableAllLanguages、EnableAllDimensions。\nAddPage # 向站点添加页面。最小需要设置 path 字段，建议同时设置 title。\n示例（content/books/_content.gotmpl）：\n{{ $content := dict \u0026#34;mediaType\u0026#34; \u0026#34;text/markdown\u0026#34; \u0026#34;value\u0026#34; \u0026#34;The _Hunchback of Notre Dame_ was written by Victor Hugo.\u0026#34; }} {{ $page := dict \u0026#34;content\u0026#34; $content \u0026#34;kind\u0026#34; \u0026#34;page\u0026#34; \u0026#34;path\u0026#34; \u0026#34;the-hunchback-of-notre-dame\u0026#34; \u0026#34;title\u0026#34; \u0026#34;The Hunchback of Notre Dame\u0026#34; }} {{ .AddPage $page }} AddResource # 向站点添加页面资源（例如封面图片）。示例：\n{{ with resources.Get \u0026#34;images/a.jpg\u0026#34; }} {{ $content := dict \u0026#34;mediaType\u0026#34; .MediaType.Type \u0026#34;value\u0026#34; . }} {{ $resource := dict \u0026#34;content\u0026#34; $content \u0026#34;path\u0026#34; \u0026#34;the-hunchback-of-notre-dame/cover.jpg\u0026#34; }} {{ $.AddResource $resource }} {{ end }} 在页面模板中使用资源示例（layouts/page.html）：\n{{ with .Resources.Get \u0026#34;cover.jpg\u0026#34; }} \u0026lt;img src=\u0026#34;{{ .RelPermalink }}\u0026#34; width=\u0026#34;{{ .Width }}\u0026#34; height=\u0026#34;{{ .Height }}\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; {{ end }} Site # 返回要将页面添加到的 Site 对象。\n{{ .Site.Title }} 注意：从内容适配器内调用时，Site 尚未完全构建，像 .Site.Pages 这类依赖已构建页面集合的方法会报错。\nStore # 返回一个持久化的“便签”（scratch pad），可在多次执行间存取数据。主要用于在启用多语言（EnableAllLanguages）时在不同执行之间传递值。\n{{ .Store.Set \u0026#34;key\u0026#34; \u0026#34;value\u0026#34; }} {{ .Store.Get \u0026#34;key\u0026#34; }} EnableAllLanguages # 默认情况下，Hugo 只为站点矩阵（sites matrix）中第一个匹配的站点执行内容适配器一次。调用此方法可扩展到所有语言（保持当前 role 与 version）。\n{{ .EnableAllLanguages }} {{ $content := dict \u0026#34;mediaType\u0026#34; \u0026#34;text/markdown\u0026#34; \u0026#34;value\u0026#34; \u0026#34;The _Hunchback of Notre Dame_ was written by Victor Hugo.\u0026#34; }} {{ $page := dict \u0026#34;content\u0026#34; $content \u0026#34;kind\u0026#34; \u0026#34;page\u0026#34; \u0026#34;path\u0026#34; \u0026#34;the-hunchback-of-notre-dame\u0026#34; \u0026#34;title\u0026#34; \u0026#34;The Hunchback of Notre Dame\u0026#34; }} {{ .AddPage $page }} EnableAllDimensions (v0.153.0) # 默认情况下内容适配器仅为 sites matrix 的第一个匹配项执行。EnableAllDimensions 用于扩展执行到语言、role、version 的所有可能组合（更细粒度控制可通过 front matter 中的 sites.matrix 或 content mount 定义）。\n页面映射（Page map） # 调用 AddPage 时传入的 map 可设置任意 front matter 字段（不包括 markup），若要指定标记类型请设置 content.mediaType。下表列出常用字段：\nKey 描述 必需 content.mediaType 内容的媒体类型，默认 text/markdown。 content.value 内容字符串值。 dates.date 创建日期（time.Time）。 dates.expiryDate 过期日期（time.Time）。 dates.lastmod 最后修改时间（time.Time）。 dates.publishDate 发布时间（time.Time）。 params 页面参数 map。 path 相对于内容适配器的页面逻辑路径（不要带前导斜杠或扩展名）。 ✔️ title 页面标题。 提示：虽然 path 是唯一必需字段，但建议同时设定 title。Hugo 会将 path 自动规范化（例如 A B C -\u0026gt; /section/a-b-c）。\n资源映射（Resource map） # AddResource 使用的 map 字段说明：\nKey 描述 必需 content.mediaType 资源的媒体类型。 ✔️ content.value 字符串或资源对象（string 或 resource）。 ✔️ name 资源名称。 params 资源参数 map。 path 相对于内容适配器的资源逻辑路径（不要带前导斜杠）。 ✔️ title 资源标题。 说明：\n当 content.value 为字符串时，Hugo 会为页面生成一个新资源，其发布路径相对于页面。 当 content.value 已经是一个 resource（比如通过 resources.GetRemote 得到的资源），Hugo 会直接使用该资源并按站点根发布，这种方式更高效。 路径会被规范化，例如 A B C/cover.jpg -\u0026gt; /section/a-b-c/cover.jpg。 示例：从远程数据生成书评页面 # 目标：从远程 JSON 创建每本书的页面，并为每本书添加封面资源。\n步骤 1 — 创建内容结构：\ncontent/ └── books/ ├── _content.gotmpl \u0026lt;-- content adapter └── _index.md 步骤 2 — 查看远程数据结构（示例）：\nhttps://gohugo.io/shared/examples/data/books.json 步骤 3 — 创建内容适配器（content/books/_content.gotmpl）：\n{{/* Get remote data. */}} {{ $data := dict }} {{ $url := \u0026#34;\u0026lt;https://gohugo.io/shared/examples/data/books.json\u0026gt;\u0026#34; }} {{ with try (resources.GetRemote $url) }} {{ with .Err }} {{ errorf \u0026#34;Unable to get remote resource %s: %s\u0026#34; $url . }} {{ else with .Value }} {{ $data = . | transform.Unmarshal }} {{ else }} {{ errorf \u0026#34;Unable to get remote resource %s: %s\u0026#34; $url }} {{ end }} {{ end }} {{/* Add pages and page resources. */}} {{ range $data }} {{/* Add page. */}} {{ $content := dict \u0026#34;mediaType\u0026#34; \u0026#34;text/markdown\u0026#34; \u0026#34;value\u0026#34; .summary }} {{ $dates := dict \u0026#34;date\u0026#34; (time.AsTime .date) }} {{ $params := dict \u0026#34;author\u0026#34; .author \u0026#34;isbn\u0026#34; .isbn \u0026#34;rating\u0026#34; .rating \u0026#34;tags\u0026#34; .tags }} {{ $page := dict \u0026#34;content\u0026#34; $content \u0026#34;dates\u0026#34; $dates \u0026#34;kind\u0026#34; \u0026#34;page\u0026#34; \u0026#34;params\u0026#34; $params \u0026#34;path\u0026#34; .title \u0026#34;title\u0026#34; .title }} {{ $.AddPage $page }} {{/* Add page resource. */}} {{ $item := . }} {{ with $url := $item.cover }} {{ with try (resources.GetRemote $url) }} {{ with .Err }} {{ errorf \u0026#34;Unable to get remote resource %s: %s\u0026#34; $url . }} {{ else with .Value }} {{ $content := dict \u0026#34;mediaType\u0026#34; .MediaType.Type \u0026#34;value\u0026#34; .Content }} {{ $params := dict \u0026#34;alt\u0026#34; $item.title }} {{ $resource := dict \u0026#34;content\u0026#34; $content \u0026#34;params\u0026#34; $params \u0026#34;path\u0026#34; (printf \u0026#34;%s/cover.%s\u0026#34; $item.title .MediaType.SubType) }} {{ $.AddResource $resource }} {{ else }} {{ errorf \u0026#34;Unable to get remote resource %s: %s\u0026#34; $url }} {{ end }} {{ end }} {{ end }} {{ end }} 步骤 4 — 创建页面模板（layouts/books/page.html）：\n{{ define \u0026#34;main\u0026#34; }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ with .Resources.GetMatch \u0026#34;cover.*\u0026#34; }} \u0026lt;img src=\u0026#34;{{ .RelPermalink }}\u0026#34; width=\u0026#34;{{ .Width }}\u0026#34; height=\u0026#34;{{ .Height }}\u0026#34; alt=\u0026#34;{{ .Params.alt }}\u0026#34;\u0026gt; {{ end }} \u0026lt;p\u0026gt;Author: {{ .Params.author }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; ISBN: {{ .Params.isbn }}\u0026lt;br\u0026gt; Rating: {{ .Params.rating }}\u0026lt;br\u0026gt; Review date: {{ .Date | time.Format \u0026#34;:date_long\u0026#34; }} \u0026lt;/p\u0026gt; {{ with .GetTerms \u0026#34;tags\u0026#34; }} \u0026lt;p\u0026gt;Tags:\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; {{ range . }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} {{ .Content }} {{ end }} 多语言站点支持 # 有两种常见方法处理多语言内容适配器：\n在一个内容适配器中使用 EnableAllLanguages 为所有语言生成内容。 为每种语言创建独立的内容适配器（按文件名或按目录）。 通过文件名区分语言 # 示例站点配置（按语言权重）：\nYAML / TOML / JSON 示例均可。然后在 content/books/ 下放置：\ncontent/ └── books/ ├── _content.de.gotmpl ├── _content.en.gotmpl ├── _index.de.md └── _index.en.md 通过内容目录区分语言 # 在配置中指定每个语言的 contentDir，例如：\n示例目录结构：\ncontent/ ├── de/ │ └── books/ │ ├── _content.gotmpl │ └── _index.md └── en/ └── books/ ├── _content.gotmpl └── _index.md 页面冲突（Page collisions） # 当两个或更多页面具有相同发布路径时会发生冲突（例如内容适配器生成的页面与目录中已有的 .md 文件路径相同）。由于构建过程是并发的，被发布页面的内容将不确定，无法控制处理顺序。\n示例：\ncontent/ └── books/ ├── _content.gotmpl \u0026lt;-- content adapter ├── _index.md └── the-hunchback-of-notre-dame.md 如果内容适配器也创建 books/the-hunchback-of-notre-dame，则该路径会冲突。构建时可使用 --printPathWarnings 标志来检测此类冲突。\n参考与最后更新 # 文档来源：Hugo 官方文档 - Content adapters（含示例与方法说明） ","date":"2025-12-05","externalUrl":null,"permalink":"/posts/hugo-content-adapters/","section":"文章","summary":"","title":"Hugo 动态内容的利器——Content Adapters","type":"posts"},{"content":"","date":"2025-12-05","externalUrl":null,"permalink":"/tags/%E8%BF%9B%E9%98%B6/","section":"标签","summary":"","title":"进阶","type":"tags"},{"content":"","date":"2025-11-27","externalUrl":null,"permalink":"/tags/git/","section":"标签","summary":"","title":"Git","type":"tags"},{"content":" Git 常用命令详解与实用指南 # 本文总结了Git的核心命令，涵盖从初始化仓库到远程协作的各个方面，帮助你高效管理代码版本。\n初始化与配置 # # 初始化本地Git仓库 git init # 配置全局用户名和邮箱 git config --global user.name \u0026#34;你的用户名\u0026#34; git config --global user.email \u0026#34;你的邮箱\u0026#34; # 启用命令输出颜色，提升可读性 git config --global color.ui true git config --global color.status auto git config --global color.diff auto git config --global color.branch auto git config --global color.interactive auto # 取消HTTP代理设置 git config --global --unset http.proxy 克隆与远程仓库操作 # # 克隆远程仓库 git clone git+ssh://git@192.168.53.168/VT.git # 添加远程仓库地址 git remote add origin git+ssh://git@192.168.53.168/VT.git # 查看远程仓库分支 git branch -r # 获取远程分支数据（不自动合并） git fetch git fetch --prune # 同时清理远程已删除分支 # 拉取远程分支并合并到当前分支 git pull origin master # 推送当前分支到远程仓库 git push origin master # 推送所有标签 git push --tags # 删除远程分支 git push origin :hotfixes/BJVEP933 版本状态查看与文件管理 # # 查看当前仓库状态 git status # 将文件添加到暂存区 git add xyz git add . # 添加当前目录所有变更文件 # 提交改动 git commit -m \u0026#39;提交信息\u0026#39; # 修改上一次提交信息 git commit --amend -m \u0026#39;新的提交信息\u0026#39; # 一步完成添加并提交（仅限已跟踪文件） git commit -am \u0026#39;提交信息\u0026#39; # 删除文件（同时从暂存区和工作区删除） git rm 文件名 # 递归删除当前目录所有文件 git rm -r * # 重命名文件 git mv README README2 # 查看Git索引包含的文件 git ls-files 日志查看与版本比较 # # 显示提交日志 git log # 显示最近1条日志 git log -1 # 显示最近5条日志 git log -5 # 显示日志及相关文件变动统计 git log --stat # 显示详细的提交差异 git log -p -m # 查看指定提交的详细信息 git show dfb02e6 # 查看最新提交 git show HEAD # 查看上一个版本提交 git show HEAD^ # 查看标签信息 git tag git tag -a v2.0 -m \u0026#39;版本说明\u0026#39; # 创建带注释的标签 # 查看标签的提交信息 git show v2.0 # 查看标签的日志 git log v2.0 # 显示未暂存的文件差异 git diff # 显示已暂存但未提交的变更 git diff --cached # 比较与上一个版本的差异 git diff HEAD^ # 比较指定目录的差异 git diff HEAD -- ./lib # 比较远程分支与本地分支差异 git diff origin/master..master # 只显示差异文件列表，不显示内容 git diff origin/master..master --stat 分支管理 # # 查看本地分支 git branch # 查看所有本地和远程分支 git branch -a # 显示所有远程分支 git branch -r # 显示包含特定提交的分支 git branch --contains 50089 # 显示已合并到当前分支的分支 git branch --merged # 显示未合并到当前分支的分支 git branch --no-merged # 本地分支重命名 git branch -m master master_copy # 创建并切换到新分支 git checkout -b master_copy # 从远程分支创建本地新分支并切换 git checkout -b devel origin/develop # 切换到已有分支 git checkout features/performance # 检出远程分支并建立跟踪 git checkout --track hotfixes/BJVEP933 # 切换到标签版本 git checkout v2.0 # 删除本地分支（已合并） git branch -d hotfixes/BJVEP933 # 强制删除本地分支（未合并） git branch -D hotfixes/BJVEP933 合并与变基 # # 合并远程master分支到当前分支 git merge origin/master # 选择性合并某次提交 git cherry-pick ff44785404a8e # 变基操作 git rebase 重置与回滚 # # 硬重置到HEAD版本（丢弃未提交修改） git reset --hard HEAD # 撤销指定提交的影响（生成新提交） git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 检出某个文件回到HEAD版本（恢复文件） git checkout -- README 暂存区操作（stash） # # 暂存当前修改，恢复工作区为HEAD状态 git stash # 查看暂存列表 git stash list # 显示某次暂存内容 git stash show -p stash@{0} # 应用某次暂存内容 git stash apply stash@{0} 其他实用命令 # # 搜索文件内容包含\u0026#34;delete from\u0026#34;的文本 git grep \u0026#34;delete from\u0026#34; # 使用多个条件搜索 git grep -e \u0026#39;#define\u0026#39; --and -e SORT_DIRENT # 垃圾回收，优化仓库空间 git gc # 检查仓库完整性 git fsck # 查看分支历史图示 git show-branch git show-branch --all # 查看提交历史对应的文件修改 git whatchanged # 查看所有提交记录（包括孤立提交） git reflog # 查看HEAD@{5}的状态 git show HEAD@{5} # 查看master分支昨天的状态 git show master@{yesterday} # 图示日志简洁视图 git log --pretty=format:\u0026#39;%h %s\u0026#39; --graph # 查看特定提交的原始详细信息 git show -s --pretty=raw 2be7fcb476 通过熟练掌握以上Git命令，可以极大提高代码管理效率，轻松应对团队协作中的各种版本控制需求。\n提示：\n命令中的\u0026quot;xxx\u0026quot;和示例地址请替换为实际的用户名、邮箱和仓库地址。 使用命令前建议先了解各命令的具体作用，避免误操作造成数据丢失。 ","date":"2025-11-27","externalUrl":null,"permalink":"/posts/git-common-commands-guide/","section":"文章","summary":"","title":"Git 常用命令详解与实用指南","type":"posts"},{"content":"","date":"2025-11-19","externalUrl":null,"permalink":"/tags/comment/","section":"标签","summary":"","title":"Comment","type":"tags"},{"content":"","date":"2025-11-19","externalUrl":null,"permalink":"/tags/giscus/","section":"标签","summary":"","title":"Giscus","type":"tags"},{"content":" Hugo 安装 giscus 评论系统教程 # 主流评论系统横向比较 # 评论系统 免费度 隐私保护 易用性 Hugo 集成方式 主要优缺点 Disqus 免费（基础版），付费高级功能 中等（第三方服务器，广告追踪） 高（简单 JS 嵌入） JS 嵌入或短代码 优点：用户基数大，功能丰富（如通知）；缺点：隐私差，加载慢，广告多。 Utterances 完全免费 高（GitHub 托管，无追踪） 中等（需 GitHub repo） JS 嵌入或短代码 优点：开源，轻量，版本控制；缺点：需 GitHub 账号，回复依赖 GitHub。 giscus 完全免费 高（GitHub Discussions 托管） 高（配置简单） JS 嵌入或短代码 优点：实时通知，主题自定义，支持多语言；缺点：依赖 GitHub，搜索功能有限。 Remark42 完全免费（自托管） 高（自托管，无第三方） 低（需服务器） JS 嵌入，自托管后端 优点：完全控制数据，轻量；缺点：部署复杂，需维护服务器。 Staticman 完全免费（自托管） 高（静态提交，无 JS） 中等（Webhook 配置） 短代码 + Webhook 优点：无 JS，SEO 友好；缺点：非实时，需后端处理表单。 数据来源：基于 Hugo 官方文档和社区推荐（2025 年最新）。选择评论系统时，建议优先考虑隐私需求和站点规模。\ngiscus 简介 # giscus 是一个基于 GitHub Discussions 构建的开源、轻量级评论系统。它允许用户在 Hugo 等静态站点上嵌入 GitHub 风格的评论线程，无需搭建第三方服务器。\n核心优势：\n免费且隐私友好：数据全部存储在 GitHub，无广告追踪，符合 GDPR。 实时交互：支持 @提及、表情反应、代码高亮、多语言。 自定义性强：主题、语言及讨论类别可调节。 Hugo 兼容性好：支持短代码，适合单页或多页站点。 局限性：\n依赖 GitHub 账号，适合开源项目或拥有 GitHub 仓库的用户。 不支持匿名评论，默认需登录 GitHub。 giscus 自 2021 年推出以来持续活跃维护，是 Hugo 用户，尤其是开发者社区的热门选择。\ngiscus 详细安装步骤 # 假设你已有一个 Hugo 项目和 GitHub 账号，整个过程预计 15-30 分钟完成。\n1: 在 GitHub 上创建并配置仓库 # 登录 GitHub，创建一个公共仓库（或使用现有仓库）作为你的 Hugo 站点仓库。 在仓库设置中启用 Discussions 功能： 进入仓库 Settings \u0026gt; Features \u0026gt; 启用 Discussions。 创建一个 Discussions 类别（Category），如“Comments”或“Q\u0026amp;A”，作为评论线程的存储空间。 2: 生成 giscus 配置 # 访问 giscus 配置页面。 填写仓库信息： Repository：例如 GitHub用户名/仓库名 Category：选择之前创建的类别，如 \u0026ldquo;General\u0026rdquo; Mapping：选择 \u0026ldquo;pathname\u0026rdquo;，基于页面路径映射评论线程 Reactions：启用（可选，用于点赞） Theme：选择 \u0026ldquo;light\u0026rdquo; 或 \u0026ldquo;dark\u0026rdquo;，支持 Hugo 主题动态切换 Language：选择站点语言，如 \u0026ldquo;zh-CN\u0026rdquo; 点击 Generate，复制生成的 \u0026lt;script\u0026gt; 标签代码。 3: 在 Hugo 中集成 giscus # Hugo 支持通过短代码或直接 JS 脚本嵌入集成，推荐使用短代码方便管理。\n选项 A：使用 Hugo 短代码（推荐） 在 Hugo 主题或项目根目录下的 layouts/shortcodes/ 创建文件 giscus.html。 将以下代码粘贴进去，替换为你自己的仓库和类别 ID（可从 giscus.app 获取）： \u0026lt;script src=\u0026#34;\u0026lt;https://giscus.app/client.js\u0026gt;\u0026#34; data-repo=\u0026#34;yourusername/your-repo\u0026#34; data-repo-id=\u0026#34;YOUR_REPO_ID\u0026#34; data-category=\u0026#34;General\u0026#34; data-category-id=\u0026#34;YOUR_CATEGORY_ID\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;light\u0026#34; data-lang=\u0026#34;zh-CN\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 在你的 Markdown 内容页中插入短代码 这样评论区会自动显示在页面底部。\n选项 B：直接 JS 嵌入（适用于单页面） 在 Hugo 布局文件如 layouts/_default/single.html 底部添加：\n\u0026lt;div id=\u0026#34;giscus-comments\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;\u0026lt;https://giscus.app/client.js\u0026gt;\u0026#34; ... \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 替换为完整配置 --\u0026gt; 4: 自定义与优化 # 主题切换：将 data-theme 设置为 preferred_color_scheme，自动匹配暗/亮模式。 多语言支持：利用 Hugo 条件逻辑动态修改 data-lang。 隐私增强：通过设置 data-emit-metadata=\u0026quot;0\u0026quot; 禁止发送元数据。 构建站点：运行 hugo 生成静态站点，giscus 以 JS 方式加载，不影响构建。 5：测试与验证 # 启动本地服务器：hugo server 访问页面，确保评论区正常显示并可登录 GitHub 发表评论。 第一次评论将自动创建对应的 Discussions 线程。 常见问题排查 # 问题 解决方案 评论不显示 确认仓库为公共，Discussions 功能已启用；检查浏览器控制台是否有 JS 错误。 跨域问题 确保 \u0026lt;script\u0026gt; 标签中含有 crossorigin=\u0026quot;anonymous\u0026quot; 属性。 性能问题 giscus 异步加载，不会阻塞页面加载。 更新与帮助 参考官方文档 https://giscus.app/ 获取最新信息。 完成以上步骤后，你的 Hugo 站点即可拥有一个现代化、隐私友好且功能丰富的 GitHub 驱动评论系统。如遇安装或配置问题，欢迎提供具体站点信息以便进一步调试！\n","date":"2025-11-19","externalUrl":null,"permalink":"/posts/hugo-comments-systems-comparison-giscus-setup/","section":"文章","summary":"","title":"Hugo 安装 giscus 评论系统教程","type":"posts"},{"content":" Hugo安装教程（WIN11系统） # 在Windows系统上安装Hugo非常简单，这里主要介绍用Chocolatey包管理器安装的方法，因为这种方法最适合开发者，因为它可以一键安装，并且方便后续的升级和管理。\nChocolatey简介 # Chocolatey（简称 Choco）是一个开源的Windows 包管理器，类似于 Linux 的 apt-get/yum 或 macOS 的 Homebrew。它通过命令行方式自动化管理 Windows 上的软件安装、更新、配置和卸载，基于 NuGet 包格式和 PowerShell 脚本实现。\n安装Chocolatey（如果您还没有安装） # 以管理员身份打开Windows PowerShell（右键点击开始菜单的PowerShell图标，选择“以管理员身份运行”）。 复制以下命令并粘贴到PowerShell中，然后按回车： Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 安装后，验证。\nchoco -v 使用Chocolatey安装Hugo（推荐安装扩展版） # 在同一个（管理员）PowerShell 窗口中，输入以下命令并回车： choco install hugo-extended -y 验证安装 # 关闭并重新打开一个新的 PowerShell 或命令提示符窗口（无需管理员权限），输入以下命令： hugo version 如果安装成功，你会看到类似这样的输出，显示 Hugo 的版本号：\nhugo v0.132.3-8a4c63af6e5f4b7b8de5a2e195a94f8d6c4f3fd2 windows/amd64 BuildDate=2024-05-31T11:15:06Z VendorInfo=gohugoio ","date":"2025-11-11","externalUrl":null,"permalink":"/posts/hugo-win-intall/","section":"文章","summary":"","title":"Hugo安装教程（WIN11系统）","type":"posts"},{"content":"","date":"2025-11-11","externalUrl":null,"permalink":"/tags/win/","section":"标签","summary":"","title":"Win","type":"tags"},{"content":"","date":"2025-11-11","externalUrl":null,"permalink":"/tags/%E5%AE%89%E8%A3%85/","section":"标签","summary":"","title":"安装","type":"tags"},{"content":" Hugo 模块（Hugo Modules）使用指南 # Hugo 模块（Hugo Modules）简介 # Hugo Modules 是 Hugo（静态网站生成器）从 v0.56.0 版本引入的依赖管理机制，基于 Go Modules 实现，主要用于管理主题（themes）、组件、内容、资产等外部依赖。相比传统的 Git submodules 或手动复制主题文件，Hugo Modules 的安装和使用有以下主要优点：\n**更简单的依赖管理和更新。**Hugo 自动处理依赖的下载、版本跟踪和文件集成。只需在配置文件（如 hugo.toml）中声明 imports，运行 hugo mod get 或直接构建站点即可自动拉取和更新。无需手动执行 git submodule update 等复杂命令，避免了 submodules 常见的克隆、更新和同步问题。 **干净的项目结构。**主题和依赖不会直接污染站点仓库的 themes 目录（无需物理文件夹），保持站点仓库简洁。只有 go.mod 和 go.sum 文件记录依赖，便于版本控制和协作。适合多人开发或开源项目。 **精确的版本控制和可复现性。**使用 Go Modules 的语义化版本管理（semantic versioning），可以锁定特定版本，确保不同环境构建一致。更新时只需 hugo mod get -u 或指定版本，避免 submodules 的 detached HEAD 或手动 commit 问题。 **灵活的挂载（mounts）和组件复用。**支持将外部模块的任意组件（layouts、assets、content、data 等）挂载到站点任意路径，实现高度模块化。便于复用组件、共享内容或构建复杂站点，而非仅限于主题。 **自动缓存和性能优化。**模块缓存到本地（默认 ~/go/pkg/mod），后续构建更快。支持代理和 workspace 模式，适合大型项目或 CI/CD 部署（如 Netlify、Vercel）。 避免 Git submodules 的痛点 无需特殊克隆命令（如 \u0026ndash;recurse-submodules）。 更容易自定义主题（通过 replacements 支持本地开发）。 减少手动操作错误，提高开发效率和迭代速度。 1. 前提条件 # 需要安装 Go 1.18 及以上版本 需要安装 Git 对于在 Netlify 上托管的旧网站，确保环境变量 GO_VERSION 设置为 1.18 或更高版本。 2. 初始化新模块 # 使用命令初始化新的 Hugo 模块：\nhugo mod init github.com/\u0026lt;你的GitHub用户名\u0026gt;/\u0026lt;你的项目名\u0026gt; 如果 Hugo 无法自动推断模块路径，需要手动传入路径参数。\n3.在配置文件中添加主题模块 # 在配置文件中添加主题模块导入（支持 YAML、TOML 和 JSON 格式），path对应 github.com/仓库名：\nYAML 示例\nmodule: imports: - path: github.com/spf13/hyde TOML 示例\n[module] [[module.imports]] path = \u0026#34;github.com/spf13/hyde\u0026#34; JSON 示例\n{ \u0026#34;module\u0026#34;: { \u0026#34;imports\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;github.com/spf13/hyde\u0026#34; } ] } } 4. 模块更新管理 # 模块会在配置中作为导入时自动下载和添加。你可以使用 hugo mod get 命令来更新和管理版本。\n常用示例 # 更新所有模块： hugo mod get -u 递归更新所有模块： hugo mod get -u ./... 更新某个指定模块： hugo mod get -u github.com/gohugoio/myShortcodes 获取指定版本模块： hugo mod get github.com/gohugoio/myShortcodes@v1.0.7 5. 本地开发：模块修改与测试 # 为方便本地开发，可以在 go.mod 文件中添加替换指令，将模块指向本地目录：\nreplace github.com/bep/hugotestmods/mypartials =\u0026gt; /Users/bep/hugotestmods/mypartials 当你运行 hugo server 时，配置会自动重载，且本地目录会被监视以实现热更新。\n也可以通过配置文件中的 replacements 选项实现替换，避免直接修改 go.mod。\n6. 打印依赖关系图 # 运行以下命令可以显示模块依赖关系，包括替换和禁用状态：\nhugo mod graph 示例输出：\ngithub.com/bep/my-modular-site github.com/bep/hugotestmods/mymounts@v1.2.0 github.com/bep/my-modular-site github.com/bep/hugotestmods/mypartials@v1.0.7 ... (省略) 7. 模块依赖的供应商化（Vendor） # 执行以下命令将所有依赖写入 _vendor 目录：\nhugo mod vendor 注意事项：\n可在模块树的任意层级执行命令 不会存储 themes 目录中的模块 多数命令支持 -ignoreVendorPaths 标志，允许忽略特定路径的供应商模块 8. 清理与整理模块缓存 # 运行 hugo mod tidy 清理 go.mod 和 go.sum 中未使用的依赖条目 运行 hugo mod clean 删除整个模块缓存 更多缓存配置请参考：缓存配置\n命令文档：\nhugo mod tidy hugo mod clean 9. 模块工作空间支持 # 从 Go 1.18 开始支持工作空间，Hugo 从 v0.109.0 开始支持工作空间功能。此功能方便同时开发站点和主题模块。\n配置方法 # 创建 .work 文件，例如 hugo.work，内容示例： go 1.20 use . use ../gohugoioTheme 通过 HUGO_MODULE_WORKSPACE 环境变量激活工作空间： HUGO_MODULE_WORKSPACE=hugo.work hugo server --ignoreVendorPaths \u0026#34;**\u0026#34; -ignoreVendorPaths 选项用于忽略 _vendor 目录下的依赖，方便本地开发实时同步修改。 更多详情请访问官方文档：Hugo Modules 使用指南\n","date":"2025-11-06","externalUrl":null,"permalink":"/posts/use-hugo-modules/","section":"文章","summary":"","title":"Hugo 模块使用指南","type":"posts"},{"content":" Hugo Gallery 主题：简单而实用的 Hugo 照片画廊主题 # Hugo Gallery 是一个非常简单且具有明确设计理念的 Hugo 照片画廊主题，适合想要快速搭建美观相册网站的用户。\n主题演示地址：Demo 示例站点源码：Example site source 主要特点 # 响应式设计，兼容各种设备 支持暗色配色方案，可为每个页面单独设置 支持私密相册，不在公开列表中展示 利用 Flickr 的 Justified Layout 实现整齐的相册视图 集成 PhotoSwipe 轻盒子查看图片 SEO 优化，支持 Open Graph 标签 自动或手动选择封面图作为相册缩略图 重要提示： 请避免使用 WebP 格式图片。因 Hugo 内置的 Go 语言 WebP 实现存在缩放时色阶错误的 bug，导致图片颜色暗淡。详见相关问题讨论。\n安装指南 # 该主题要求 Hugo Extended 版本 \u0026gt;= 0.123.0，所有依赖均已打包，无需额外安装 Node.js 或 PostCSS。\n作为 Hugo 模块安装 # 需要安装 Go 语言环境。\nhugo mod init github.com/\u0026lt;your_user\u0026gt;/\u0026lt;your_project\u0026gt; 然后在 hugo.toml 添加主题依赖：\n[module] [[module.imports]] path = \u0026#34;github.com/nicokaiser/hugo-theme-gallery/v4\u0026#34; 作为 Git 子模块安装 # git submodule add --depth=1 \u0026lt;https://github.com/nicokaiser/hugo-theme-gallery.git\u0026gt; themes/gallery 使用说明 # 页面包只要包含至少一张图片，即被当作相册或画廊列出。目录结构示例：\ncontent/ ├── _index.md ├── about.md \u0026lt;-- 不在相册列表中 ├── animals/ │ ├── _index.md │ ├── cats/ │ │ ├── index.md │ │ ├── cat1.jpg │ │ └── feature.jpg \u0026lt;-- 相册封面 │ ├── dogs/ │ │ ├── index.md │ │ ├── dog1.jpg \u0026lt;-- 相册封面 │ │ └── dog2.jpg │ └── feature.jpg ├── bridge.jpg \u0026lt;-- 网站缩略图（用于 OpenGraph 等） └── nature/ ├── index.md \u0026lt;-- 对 tree.jpg 设置封面 ├── nature1.jpg ├── nature2.jpg └── tree.jpg \u0026lt;-- 相册缩略图 /about.md 不是页面包且无图片资源，不显示在相册列表。 /nature 是叶子包（含 index.md 且无子目录），显示为画廊。 /animals 是分支包（含 _index.md 且有子目录），显示为相册列表。 文件名含 feature 的图片或首张图片用作相册缩略图。 没有图片的相册不会显示。 Front Matter 配置 # 配置项 说明 title 相册标题，显示在列表及相册页面 date 相册日期，用于排序（默认最新优先） description 相册描述，支持 Markdown 格式 weight 调整排序权重 params.featured_image 相册缩略图文件名，优先级高（已弃用，推荐使用 resources.params.cover） params.private 设为 true 则相册不显示在列表和 RSS 中 params.featured 设为 true，该相册首页展示（即使私密） params.sort_by 图片排序依据，默认 Name，可选 Date params.sort_order 排序顺序，asc 或 desc，默认升序 params.theme 页面配色方案，默认使用站点配置的 defaultTheme 选择相册封面 # 默认使用相册目录中的第一张图片作为封面。也可通过页面包中资源的 cover 参数指定封面图片：\n--- title: Nature resources: - src: tree.jpg params: cover: true --- 如果想隐藏封面图片不出现在画廊中，可额外设置 hidden: true：\n--- title: Nature resources: - src: nature-cover.jpg params: cover: true hidden: true --- 图片元数据 # 轻盒子显示的图片标题优先读取 EXIF 中的 ImageDescription 标签，或资源元数据 title。\n可以用 exiftool 添加 EXIF 描述：\nexiftool -ImageDescription=\u0026#34;A closeup of a gray cat\u0026#39;s face\u0026#34; cat-4.jpg 也可在 Front Matter 里定义：\n--- date: 2024-02-18T14:12:44+0100 title: Cats resources: - src: cat-1.jpg title: Brown tabby cat on white stairs params: date: 2024-02-18T13:04:30+0100 - src: cat-4.jpg title: A closeup of a gray cat\u0026#39;s face --- 这还支持自定义排序：\n--- sort_by: Params.weight resources: - src: image-1.jpg params: weight: 20 - src: image-2.jpg params: weight: 10 --- 分类管理 # 如果为相册添加了分类，首页会显示分类列表。确保站点配置中 disabledKinds 未禁用 term。\n示例 content/dogs/index.md：\n--- date: 2023-01-12 title: Dogs categories: [\u0026#34;animals\u0026#34;, \u0026#34;nature\u0026#34;] resources: - src: dogs-title-image.jpg params: cover: true --- 分类也可以自定义标题和描述，放在 content/categories/\u0026lt;category\u0026gt;/_index.md：\n--- title: Cute Animals description: This is the description text of the \u0026#34;animals\u0026#34; category. --- 分类列表页 # 确保 taxonomy 没有被禁用，且每个分类目录下有图片时，访问 /categories 可以看到带封面的分类列表。\n其他分类法 # 除了 categories 和 tags，还可以使用自定义分类法如 series，但需要手动启用和配置。\n首页特色内容 # 相册或分类页可以通过 params.featured: true 标记为首页特色内容：\n--- title: Featured Album params: featured: true --- 配合 private: true 可使相册只在首页显示，不出现在列表中。\n默认首页显示内容：\n站点标题 所有分类链接（如果启用） 最新特色内容（包括私密） 所有非私密顶级相册 可通过自定义 layouts/_default/home.html 调整首页布局。\n相关内容 # 如果站点启用了关键词或标签，主题会在每个画廊下显示相关相册。配置示例（config/_default/hugo.toml）：\n[related] includeNewer = true threshold = 10 toLower = false [[related.indices]] name = \u0026#39;categories\u0026#39; weight = 10 [[related.indices]] name = \u0026#39;keywords\u0026#39; weight = 50 社交图标 # 在配置文件中使用 params.socialIcons 添加社交链接，页面底部显示对应图标：\n[params.socialIcons] facebook = \u0026#34;\u0026lt;https://www.facebook.com/\u0026gt;\u0026#34; instagram = \u0026#34;\u0026lt;https://www.instagram.com/\u0026gt;\u0026#34; github = \u0026#34;\u0026lt;https://github.com/nicokaiser/hugo-theme-gallery/\u0026gt;\u0026#34; youtube = \u0026#34;\u0026lt;https://www.youtube.com/\u0026gt;\u0026#34; email = \u0026#34;\u0026lt;mailto:user@example.com\u0026gt;\u0026#34; linkedin = \u0026#34;\u0026lt;https://linkedin.com/\u0026gt;\u0026#34; 排除原始照片 # 如需节省空间并禁止用户下载原始大图，可使用 build.publishResources 配置：\ncascade: build: publishResources: false 启用后只发布缩放后的图片，且无下载按钮。\n自定义 CSS 和 JavaScript # 主题通过 Hugo Pipes 生成 CSS，额外自定义样式放入 assets/css/custom.css。\n自定义脚本放入 assets/js/custom.js。\n","date":"2025-11-05","externalUrl":null,"permalink":"/posts/hugo-gallery-photo-gallery-theme/","section":"文章","summary":"","title":"Hugo Gallery 画廊主题简介","type":"posts"},{"content":"","date":"2025-11-05","externalUrl":null,"permalink":"/tags/%E4%B8%BB%E9%A2%98/","section":"标签","summary":"","title":"主题","type":"tags"},{"content":" Git与GitHub入门指南 # Git是一款分布式版本控制软件，用于记录代码的历史变更，支持多分支开发和远程协作。本文将带你从零开始了解Git的基本概念、优势、常用命令及工作流程，并介绍GitHub平台如何助力团队协作。\nGit和GitHub基本概念 # Git简介 # Git是一种分布式版本控制系统，意味着每个开发者本地都有完整的仓库副本，包括所有提交、分支和文件。与集中式版本控制不同，Git允许离线操作并提供更强的灵活性。\n分支轻量且易创建，支持大量分支并行开发 通过SHA哈希存储变更，适合文本文件版本管理，不适合大二进制文件 支持本地和远程仓库连接，方便推送（push）和拉取（pull）代码 Git核心组件由C语言、Shell脚本、Perl和Tcl编写，源代码托管在GitHub的git/git仓库。\nGitHub简介 # GitHub是基于Git的协作平台，支持拉取请求、代码评审、集成测试等功能，极大提升团队开发效率。开发者通常在本地使用Git进行开发，通过GitHub进行远程协作。\n学习Git与GitHub的最佳实践课程推荐GitHub学习实验室。\n为什么使用Git？ # 使用版本控制可以有效防止代码丢失，Git具有以下显著优势：\n速度快 Git通过SHA压缩技术，使代码提交和检索速度极快。\n处理合并冲突能力强 允许多人同时编辑同一文件，Git能智能处理冲突，保障团队协作顺畅。\n分支成本低 分支创建和管理成本低，开发者可以在分支中安全开发，及时推送并获得反馈。\n易于回滚 提交不可更改，只能新增替代提交，支持轻松回退到历史版本，降低开发风险。\n如何使用Git？ # 学习Git基础命令 # 推荐使用Git速查表，其中包含常用命令：\n# 克隆远程仓库 git clone [url] # 查看当前状态 git status # 查看分支 git branch # 切换分支 git checkout [branch-name] # 添加文件到暂存区 git add [file] # 提交代码并添加说明 git commit -m \u0026#34;commit message\u0026#34; # 拉取远程更新并合并 git pull # 推送本地提交 git push # 查看提交日志 git log # 查看远程仓库信息 git remote -v 更多GitHub相关的技术文档可参考GitHub帮助文档。\nGit工作流入门 # 创建分支：从主分支main切出新分支，建议以功能命名。 修改并提交：编辑代码后，使用git add和git commit保存变更。 推送代码到远程：首次推送新分支时，使用git push -u origin [branch-name]建立关联。 发起拉取请求（Pull Request）：请求将分支合并到main，便于代码审查和集成测试。 协作开发：团队成员可以在拉取请求中评论、审查并提出修改建议。 合并分支：确认无误后，将功能分支合并到main，并删除已完成的分支。 Git与GitHub初次配置 # 1、下载并安装最新版本的Git # 检查本地 Git 是否安装并可用bash\ngit --version 如果返回类似 git version 2.x.x，说明 Git 已安装。 综合一键检测脚本（复制粘贴运行） # echo \u0026#34;1. 检查 Git 版本...\u0026#34; git --version echo -e \u0026#34;\\n2. 测试 HTTPS 连接...\u0026#34; curl -I https://github.com 2\u0026gt;/dev/null | head -n 1 echo -e \u0026#34;\\n3. 测试 Git 远程访问...\u0026#34; git ls-remote https://github.com/git/git.git \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; echo \u0026#34;Git 连接 GitHub 成功\u0026#34; || echo \u0026#34;Git 连接失败\u0026#34; echo -e \u0026#34;\\n4. 测试 SSH 连接（如果使用 SSH）...\u0026#34; ssh -T git@github.com 2\u0026gt;\u0026amp;1 2、配置Git身份信息 # 打开终端，输入以下命令配置用户名和邮箱：\ngit config --global user.name \u0026#34;你的名字\u0026#34; git config --global user.email \u0026#34;你的GitHub邮箱\u0026#34; 3、配置GitHub SSH密钥（推荐） # 打开本地终端，输入以下代码，生成并添加SSH密钥，确保安全免密码推送：\n# 生成SSH密钥 ssh-keygen -t ed25519 -C \u0026#34;你的GitHub邮箱\u0026#34; # 直接回车三次使用默认路径且不设置密码 # 查看公钥内容 cat ~/.ssh/id_ed25519.pub 打开 GitHub → Settings → SSH and GPG keys → New SSH key标题随便填，粘贴刚才复制的内容 → Add SSH key\n4、测试git和GitHub连通 # 终端输入代码：\nssh -T git@github.com 成功会返回：\nHi username! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 如果提示 Permission denied (publickey)，说明 SSH 密钥未配置或未加载。\nGit基本操作流程 # 场景一：本地全新项目 → 推到 GitHub 新仓库 # # 1. 进入项目文件夹 cd /path/to/your/project # 2. 初始化 Git 仓库 git init # 3. 添加所有文件 git add . # 4. 提交（写个有意义的留言） git commit -m \u0026#34;初次提交：我的超级项目 v1.0\u0026#34; # 5. 在 GitHub 网页新建仓库（别勾初始化 README！） # 仓库名：my-awesome-project # 6. 复制 GitHub 给的 SSH 地址，例如： # git@github.com:vincentS1981/my-awesome-project.git # 7. 关联远程仓库 git remote add origin git@github.com:vincentS1981/my-awesome-project.git # 8. 推上去！（-u 记住以后直接 git push） git push -u origin main 场景二：本地已有 Git 项目 → 推到 GitHub # cd /path/to/your/existing-project # 确认已有 commit git log --oneline # 关联 + 推送（同上 7~8） git remote add origin git@github.com:vincentS1981/existing-project.git git push -u origin main 每天更新代码只需 3 行 # git add . git commit -m \u0026#34;修复了登录 bug\u0026#34; git push 场景三：克隆远程仓库到本地，开展工作流程 # 直接 clone （根据需要选择如下几种方式） ## 完整克隆项目，包括版本提交历史 git clone https://github.com/xxx/yyy.git # 或者 SSH 方式（推荐，免输密码） git clone git@github.com:xxx/yyy.git ## 仅克隆最新一次提交的代码仓库 git clone --depth=1 https://github.com/xxx/yyy.git 进入项目目录 cd yyy 查看远程分支情况 git branch -a # 查看所有分支 git remote show origin # 看远程默认分支是哪个 创建并切换到自己的开发分支（强烈推荐！不要直接在 main/master 上改） # 推荐命名方式（选一个你团队习惯的） git checkout -b feature/功能描述 # 或者 git checkout -b dev-你的名字 # 或者 git checkout -b bugfix/xxxxxx # 推到远程建立同名分支（以后就不用再加 -u 了） git push -u origin feature/功能描述 日常开发完整流程（以后每天都这么干） # 1. 每天开始工作前，先拉最新代码（防止冲突） git pull # 或者 git pull --rebase（保持线性历史） # 2. 正常写代码... # 3. 修改完了，分阶段提交（推荐小提交） git add . git commit -m \u0026#34;feat: 添加用户登录功能\u0026#34; # 4. 推送到远程自己的分支 git push # 因为之前加了 -u，这里直接 push 就行 # 5. 去 GitLab/GitHub 网页点 Merge Request / Pull Request # 让别人 review，合并到 main/master/develop 分支 场景四：本地有修改未提交，如何拉取远程合并 # # 把本地分支强制重置为远程完全一致的状态（所有本地修改全丢） git fetch origin git reset --hard origin/你的分支名 # 例如你当前在 main 分支 git fetch origin git reset --hard origin/main # 如果你想顺便清理未跟踪的文件（比如新生成的文件） git clean -fd 或者：\n# 1. 先把本地修改暂时藏起来 git stash push -m \u0026#34;临时保存的修改\u0026#34; # 2. 拉取远程并合并（或变基） git pull # 或者 git pull --rebase # 或者更稳妥： # git fetch origin # git rebase origin/main #（以 main 为例） # 3. 之后如果你还想要回刚才的修改 git stash pop # 恢复刚才藏起来的修改，可能会有冲突需要手动解决 # 如果确认不要了，直接清空stash git stash drop # 删掉最近一个 # 或 git stash clear # 清空所有stash 相关资源 # GitHub官网 GitHub学习路径 GitHub文档 GitHub市场 ","date":"2025-11-02","externalUrl":null,"permalink":"/posts/git-and-github-introduction-guide/","section":"文章","summary":"","title":"Git与GitHub入门指南","type":"posts"},{"content":"","date":"2025-10-31","externalUrl":null,"permalink":"/tags/cloudflare/","section":"标签","summary":"","title":"Cloudflare","type":"tags"},{"content":" Cloudflare托管Hugo网站完整指南 # 简介 # 本文将指导您如何将基于Hugo构建的静态网站托管到Cloudflare上，并实现从GitHub仓库的持续自动部署。即使您使用的是GitLab，步骤也大同小异。\n前提条件 # 在开始之前，请确保完成以下准备工作：\n注册并登录您的 Cloudflare账户。 注册并登录您的 GitHub账户。 在GitHub上为您的项目创建一个新的仓库。 在本地创建Git仓库，并添加远程地址指向GitHub仓库。 在本地Git仓库中创建Hugo站点，并使用 hugo server 命令测试站点是否正常运行。 官方操作步骤 # 1. 创建 wrangler.toml 配置文件 # 在项目根目录创建名为 wrangler.toml 的文件，内容如下：\nname = \u0026#34;hosting-cloudflare-worker\u0026#34; compatibility_date = \u0026#34;2025-07-31\u0026#34; [build] command = \u0026#34;chmod a+x build.sh \u0026amp;\u0026amp; ./build.sh\u0026#34; [assets] directory = \u0026#34;./public\u0026#34; not_found_handling = \u0026#34;404-page\u0026#34; 将name = “替换成部署的worker的名称“，这一步很关键\n2. 创建自动构建脚本 build.sh # 在项目根目录创建 build.sh 脚本文件，内容如下：\n#!/usr/bin/env bash #------------------------------------------------------------------------------ # @file # 构建部署Hugo站点到Cloudflare Worker的脚本 # # Cloudflare Worker会自动安装所需的Node.js依赖 #------------------------------------------------------------------------------ main() { DART_SASS_VERSION=1.93.2 GO_VERSION=1.25.3 HUGO_VERSION=0.152.2 NODE_VERSION=22.20.0 export TZ=Europe/Oslo # 安装Dart Sass echo \u0026#34;Installing Dart Sass ${DART_SASS_VERSION}...\u0026#34; curl -sLJO \u0026#34;\u0026lt;https://github.com/sass/dart-sass/releases/download/${DART_SASS_VERSION}/dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026gt;\u0026#34; tar -C \u0026#34;${HOME}/.local\u0026#34; -xf \u0026#34;dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026#34; rm \u0026#34;dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026#34; export PATH=\u0026#34;${HOME}/.local/dart-sass:${PATH}\u0026#34; # 安装Go语言 echo \u0026#34;Installing Go ${GO_VERSION}...\u0026#34; curl -sLJO \u0026#34;\u0026lt;https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz\u0026gt;\u0026#34; tar -C \u0026#34;${HOME}/.local\u0026#34; -xf \u0026#34;go${GO_VERSION}.linux-amd64.tar.gz\u0026#34; rm \u0026#34;go${GO_VERSION}.linux-amd64.tar.gz\u0026#34; export PATH=\u0026#34;${HOME}/.local/go/bin:${PATH}\u0026#34; # 安装Hugo echo \u0026#34;Installing Hugo ${HUGO_VERSION}...\u0026#34; curl -sLJO \u0026#34;\u0026lt;https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026gt;\u0026#34; mkdir \u0026#34;${HOME}/.local/hugo\u0026#34; tar -C \u0026#34;${HOME}/.local/hugo\u0026#34; -xf \u0026#34;hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026#34; rm \u0026#34;hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026#34; export PATH=\u0026#34;${HOME}/.local/hugo:${PATH}\u0026#34; # 安装Node.js echo \u0026#34;Installing Node.js ${NODE_VERSION}...\u0026#34; curl -sLJO \u0026#34;\u0026lt;https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz\u0026gt;\u0026#34; tar -C \u0026#34;${HOME}/.local\u0026#34; -xf \u0026#34;node-v${NODE_VERSION}-linux-x64.tar.xz\u0026#34; rm \u0026#34;node-v${NODE_VERSION}-linux-x64.tar.xz\u0026#34; export PATH=\u0026#34;${HOME}/.local/node-v${NODE_VERSION}-linux-x64/bin:${PATH}\u0026#34; # 验证安装情况 echo \u0026#34;Verifying installations...\u0026#34; echo Dart Sass: \u0026#34;$(sass --version)\u0026#34; echo Go: \u0026#34;$(go version)\u0026#34; echo Hugo: \u0026#34;$(hugo version)\u0026#34; echo Node.js: \u0026#34;$(node --version)\u0026#34; # 配置Git echo \u0026#34;Configuring Git...\u0026#34; git config core.quotepath false if [ \u0026#34;$(git rev-parse --is-shallow-repository)\u0026#34; = \u0026#34;true\u0026#34; ]; then git fetch --unshallow fi # 构建站点 echo \u0026#34;Building the site...\u0026#34; hugo --gc --minify } set -euo pipefail main \u0026#34;$@\u0026#34; 3. 提交并推送代码 # 将上述文件加入Git管理，提交并推送到GitHub远程仓库。\n4. 在Cloudflare中配置 # 添加Workers 登录Cloudflare控制面板，点击右上角的 Add 按钮，选择 Workers。\n开始导入仓库 在Workers页面，点击“Import a repository”旁的 Get started 按钮。\n连接GitHub 选择对应的GitHub账户，授权Cloudflare Workers和Pages访问仓库：\n选择仓库并部署 选择对应的GitHub仓库，配置应用名称，留空构建命令，点击 Create and deploy。\n访问网站 部署完成后，您即可访问托管的网站。\n自定义域名 本地修改hugo.toml中的baseURL，推送更新至GitHub仓库，cloudflare会自动重新部署：\nbaseURL = \u0026#39;替换成自定义域名\u0026#39; 最新的部署 # cloudflare-workers部署方法 # 根据最新部署情况，因为cloudflare已经内置hugo、go、npm等语言，所以可以省略bulid.sh这一步，新增的wrangler.toml配置文件如下：\nname = \u0026#34;你的cloudflare的worker的名字\u0026#34; compatibility_date = \u0026#34;2025-07-31\u0026#34; [build] command = \u0026#34;hugo --gc --minify\u0026#34; ## 一键命令替代bulid.sh [assets] directory = \u0026#34;./public\u0026#34; not_found_handling = \u0026#34;404-page\u0026#34; cloudflare-pages部署方法（推荐） # 登录 Cloudflare Dashboard。 左侧菜单：Workers \u0026amp; Pages \u0026gt; Pages \u0026gt; Create project \u0026gt; Connect to Git，选择连接你的Hugo项目所在的GitHub仓库。 配置构建设置（Build settings）： Framework preset：选择 Hugo（官方预设，会自动填充以下默认值）。\nProduction branch：通常是 main 或 master。\n生产分支：通常是 main 或 master。\nBuild command（构建命令）：如果你使用自定义域名（推荐）：直接用 hugo（或hugo \u0026ndash;gc \u0026ndash;minify——优化、清理、适合部署）。\nBuild output directory（输出目录）：public（Hugo 默认）。\nEnvironment variables（环境变量，如果你的Hugo项目限定Hugo版本或者node版本的）： • 添加键：HUGO_VERSION，值：你的 Hugo 版本号（如 0.153.2 或最新版）；\n• 添加键：NODE_VERSION，值：你的 node 版本号（如 20 或 24）； 持续部署 # 以后每当您在本地Git仓库推送更新到GitHub，Cloudflare会自动重新构建并部署您的网站，实现持续集成和部署。\n","date":"2025-10-31","externalUrl":null,"permalink":"/posts/host-hugo-site-on-cloudflare/","section":"文章","summary":"","title":"Cloudflare托管Hugo网站完整指南","type":"posts"},{"content":"","date":"2025-10-31","externalUrl":null,"permalink":"/tags/%E9%83%A8%E7%BD%B2/","section":"标签","summary":"","title":"部署","type":"tags"},{"content":" Hugo 目录结构详解 # 目录结构概述 # Hugo 是一个流行的静态网站生成器，每个 Hugo 项目是一个目录，包含多个子目录，这些子目录共同决定了网站的内容、结构、行为和展示方式。\n站点骨架 # 使用以下命令创建新站点时，Hugo 会生成如下骨架目录结构：\nhugo new site my-site 生成的目录结构示例：\nmy-site/ ├── archetypes/ # 内容模板目录 │ └── default.md ├── assets/ # 静态资源，如图片、Sass、JS等 ├── content/ # 网站内容，通常为Markdown文件 ├── data/ # 数据文件，如JSON、TOML、YAML ├── i18n/ # 多语言翻译文件 ├── layouts/ # 模板文件 ├── static/ # 静态文件，如favicon.ico、robots.txt ├── themes/ # 主题文件 └── hugo.toml # 站点配置文件 可选的配置目录结构 # 对于需求更复杂的项目，可以将配置拆分为子目录：\nmy-site/ ├── config/ │ └── _default/ │ └── hugo.toml # 其他目录同上 构建后的目录结构 # 构建网站时，Hugo 会生成 public 和 resources 目录：\nmy-site/ ├── public/ # 生成的静态网站文件 ├── resources/ # 缓存的资源文件，如CSS和图片 # 其他目录同上 主要目录说明 # 目录 说明 archetypes 新内容模板，方便快速创建新内容。 assets 资源文件，经过资产管线处理，如CSS、JS、图片。 config 配置文件目录，支持多环境配置。 content 站点内容，通常为Markdown文件。 data 额外数据文件，可用于增强内容和配置。 i18n 多语言翻译表，支持多语言网站。 layouts 模板文件，控制内容渲染方式。 public 构建生成的静态页面目录。 resources 构建时缓存资源，如压缩后的CSS和图片。 static 静态文件，直接复制到发布目录。 themes 主题目录，存放主题相关文件。 详细文档链接：Hugo 目录结构\nUnion 文件系统（Union File System） # Hugo 支持将多个目录“合并”挂载到同一位置，实现内容共享。例如：\nhome/user/ ├── my-site/ │ ├── content/ │ │ └── books/ │ └── hugo.toml └── shared-content/ └── films/ 通过配置挂载，shared-content 目录内的内容可以合并到 my-site 的 content 目录中：\nYAML 配置示例 # module: mounts: - source: content target: content - source: /home/user/shared-content target: content TOML 配置示例 # [module] [[module.mounts]] source = \u0026#39;content\u0026#39; target = \u0026#39;content\u0026#39; [[module.mounts]] source = \u0026#39;/home/user/shared-content\u0026#39; target = \u0026#39;content\u0026#39; JSON 配置示例 # { \u0026#34;module\u0026#34;: { \u0026#34;mounts\u0026#34;: [ {\u0026#34;source\u0026#34;: \u0026#34;content\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;content\u0026#34;}, {\u0026#34;source\u0026#34;: \u0026#34;/home/user/shared-content\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;content\u0026#34;} ] } } 挂载后目录结构示意：\nmy-site/ └── content/ ├── books/ └── films/ 注意：同一路径的文件优先级按照挂载顺序决定，且Hugo不支持符号链接，推荐使用union文件系统实现类似功能。\n支持挂载目录包括：archetypes、assets、content、data、i18n、layouts、static。\n详情参考：Hugo Module Mounts 和 Hugo Modules。\n主题骨架 # 通过命令创建新主题时，Hugo 生成如下基本结构：\nhugo new theme my-theme 主题目录示例：\nmy-theme/ ├── archetypes/ ├── assets/ ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ └── hugo.toml Hugo 会将主题目录挂载到项目对应位置，项目目录中的同路径文件优先级更高，方便用户覆盖主题模板。\n多主题或模块同时使用时，挂载顺序决定文件优先级。\n相关链接 # Hugo 官网 快速开始 使用指南 主题市场 社区支持 ","date":"2025-10-30","externalUrl":null,"permalink":"/posts/hugo-directory-structure/","section":"文章","summary":"","title":"Hugo静态网站目录结构详解","type":"posts"},{"content":" Hugo 快速入门指南（Mac平台） # 简介 # Hugo 是一个流行的静态网站生成器，能够帮助用户快速创建高性能的网站。本文将引导你在几分钟内搭建一个 Hugo 网站。\n前提条件 # 安装 Homebrew # 打开 Terminal（终端），输入以下命令：\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 验证 Homebrew 安装成功\nbrew --version 输出类似：\nHomebrew 4.x.x 安装 Git # brew install git 安装 Hugo Extended 版 # brew install hugo 注意（Windows 用户）：\n请避免使用命令提示符（Command Prompt）和 Windows PowerShell。 推荐使用 PowerShell（最新版）或 Linux 终端（如 WSL 或 Git Bash）。 创建站点 # 主要命令 # hugo new site quickstart cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml hugo server 执行以上命令后，你可以在终端显示的地址访问你的网站。\n命令详解 # hugo new site quickstart：创建名为 quickstart 的项目目录及基本目录结构。 cd quickstart：进入项目根目录。 git init：初始化一个空的 Git 仓库。 git submodule add https: //github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke：将 Ananke 主题作为子模块添加到项目中。 echo \u0026quot;theme = 'ananke'\u0026quot; \u0026gt;\u0026gt; hugo.toml：在配置文件中指定主题。 hugo server：启动 Hugo 开发服务器，实时预览网站。 按 Ctrl + C 停止开发服务器。\n添加内容 # 创建新内容页面：\nhugo new content/posts/my-first-post.md 此命令会在 content/posts 文件夹下生成一个 Markdown 文件，默认带有如下 Front Matter：\n+++ title = \u0026#34;My First Post\u0026#34; date = 2024-01-14T07:07:07+01:00 draft = true +++ draft = true 表示该内容为草稿，默认不会被发布。 你可以编辑正文部分，使用 Markdown 语法，例如： ## 介绍 这是**加粗**文本，和*斜体*文本。 访问 [Hugo 官网](\u0026lt;https://gohugo.io\u0026gt;) 启动开发服务器时，使用 --buildDrafts 或 -D 参数可以包含草稿内容：\nhugo server --buildDrafts # 或 hugo server -D 编辑完成并准备发布时，请将 draft 设置为 false。\nHugo 支持 CommonMark 标准的 Markdown，官方提供了在线测试工具。\n配置站点 # 在项目根目录打开 hugo.toml 配置文件，示例如下：\nbaseURL = \u0026#39;\u0026lt;https://example.org/\u0026gt;\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;My New Hugo Site\u0026#39; theme = \u0026#39;ananke\u0026#39; 需要根据实际情况修改：\nbaseURL：生产环境下网站的基础 URL，需以协议开头并以斜杠结尾。 languageCode：语言和地区代码，如 zh-cn。 title：网站标题。 保存后重新启动服务器查看效果：\nhugo server -D 不同主题可能有额外的配置项，建议查看主题的官方文档。例如，Ananke 主题的配置和使用指南见其GitHub 仓库和演示站点。\n发布站点 # 执行以下命令生成完整的静态网站文件：\nhugo 生成的文件位于 public 文件夹内，包含 HTML、图片、CSS 和 JavaScript 等资源。\n注意：默认不包含草稿、未来或过期内容。\n部署网站到服务器或托管平台请参考 Hugo 的托管与部署指南。\n重新部署 # 删掉旧站点，用第三方 trash-cli（程序员最爱，它会把文件移到废纸篓，还支持 trash-list、trash-restore 恢复。）\n# 安装（Homebrew） brew install trash # 以后永远用 trash 代替 rm trash ~/my-site # 删除my-site整个文件夹 trash *.log # 清理 Hugo 运行时产生的日志文件.log trash public/ themes/ # 典型清理 Hugo 站点时的“核弹命令” 一次性把生成文件和主题全扔废纸篓 实际使用示例（你在 Hugo 项目根目录下）\n# 你现在在 ~/Projects/my-blog 目录里 cd ~/Projects/my-blog # 1. 先把 Hugo 生成的完整站点删掉（最常用） trash public # 2. 把所有主题删掉（换新主题前常用） trash themes # 3. 把运行日志删掉 trash *.log # 4. 实在不想玩了，连源码一起删（整个站点拜拜） trash ~/Projects/my-blog # 或者直接 trash . # （点表示当前目录，慎用！） 主题安装、切换和更新 # 添加主题 # 在您的 Hugo 站点根目录下（例如 cd mysite），使用 git submodule 命令添加新主题：\ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 说明:\n新的主题仓库会被克隆到您站点的 themes/ananke 文件夹中。 您的 themes 文件夹中现在有两个主题文件夹：LoveIt 和 ananke。 主题切换 # Hugo 站点使用 配置文件（ hugo.toml ）来决定使用哪个主题。\n要切换主题，您只需要修改配置文件中的 theme 这一行配置即可。\n方式一：修改 hugo.toml 文件\n打开您站点根目录下的 hugo.toml 文件（或 config.toml）：\n如果要切换到 Ananke 主题，将配置改为：\n# hugo.toml baseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#39;ananke\u0026#39; # \u0026lt;-- 切换主题，主题名必须与文件夹名一致 方式二：使用命令行参数（临时切换）\n如果您只是想临时预览某个主题而不想永久修改配置文件，可以在运行 hugo server 时加上 --theme 参数：\nhugo server -D --theme ananke 更新主题并提交 # 要更新您已安装的主题（以主题LoveIt为例），在项目根目录下运行以下命令：\ngit submodule update --remote themes/LoveIt 回到根目录，提交更新：\ngit add themes/LoveIt 提交更改信息\ngit commit -m \u0026#34;更新主题子模块到最新版本\u0026#34; git push 从远程拉取到本地（一键拉取包括子模块！！）\ngit pull --recurse-submodules 修改主题子模块 # 先把主题fork到自己的GitHub仓库（这一步很重要）\n把fork的主题作为子模块添加到Hugo项目\ngit submodule add https://github.com/你的用户名/主题名 themes/主题名 直接在子模块里修改 + 推送\ncd themes/主题名 # 修改文件… git add . git commit -m \u0026#34;修改主题...\u0026#34; git push origin main # 直接推到原仓库 或者 git push origin feature/new # 推送到new的分支 # 回到主项目 cd ../.. git add themes/主题名 git commit -m \u0026#34;更新主题...\u0026#34; git push 相关链接 # Hugo 官网 Hugo 文档 Hugo 主题库 Hugo GitHub 仓库 ","date":"2025-10-30","externalUrl":null,"permalink":"/posts/hugo-quick-start-guide/","section":"文章","summary":"","title":"Hugo静态网站入门指南","type":"posts"},{"content":"","date":"2025-10-30","externalUrl":null,"permalink":"/tags/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","section":"标签","summary":"","title":"静态网站","type":"tags"},{"content":"","date":"2025-10-30","externalUrl":null,"permalink":"/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","section":"标签","summary":"","title":"目录结构","type":"tags"},{"content":"","externalUrl":null,"permalink":"/about/","section":"Abouts","summary":"","title":"Abouts","type":"about"},{"content":"","externalUrl":null,"permalink":"/links/","section":"Links","summary":"","title":"Links","type":"links"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 分享一些优秀的网站。 静态网站 # 名称 网址 简介 技术栈 Next.js https://nextjs.org/ 目前最流行的全栈框架，支持静态生成 (SSG) 和服务端渲染 (SSR) React, JS/TS Hugo https://gohugo.io/ 世界上构建速度最快的生成器，适合大规模内容站点 Go Astro https://astro.build/ 现代“孤岛架构”，能极大减少客户端 JS，性能极佳 React/Vue/Svelte等 Jekyll https://jekyllrb.com/ GitHub Pages 官方原生支持，老牌稳定，社区资源丰富 Ruby Hexo https://hexo.io/ 中文社区极其流行，拥有大量精美博客主题，配置简单 Node.js Docusaurus https://docusaurus.io/ Meta出品，功能最全的文档站框架，自带搜索和多语言 React VitePress https://vitepress.dev/ 基于 Vite 的极速文档生成器，Vue 官方生态首选 Vue, Vite Eleventy https://www.11ty.dev/ 极其简约灵活，无框架绑定，适合追求极致控制的开发者 Node.js Gatsby https://www.gatsbyjs.com/ 强大的 React 生态，集成 GraphQL，适合复杂数据源 React, GraphQL MkDocs https://www.mkdocs.org/ 专注于项目文档，使用 Markdown 编写，配置极其简单 Python Docsify https://docsify.js.org/ 无需构建步骤，运行时直接渲染 Markdown，非常轻量 JavaScript Nuxt.js https://nuxt.com/ Vue 生态中的通用框架，支持 SSG 模式 Vue, JS/TS Zola https://www.getzola.org/ 单个可执行文件，无依赖，速度极快 Rust 部署平台 # 平台名称 官网地址 简介 免费额度 Cloudflare Pages https://pages.cloudflare.com/ 依托 Cloudflare 顶级边缘网络，性能极佳，是目前最慷慨的平台。 无限流量 (Bandwidth)，无限站点数，每月 500 次构建，支持免费自定义域名。 Vercel https://vercel.com/ Next.js 官方平台，开发者体验（DX）天花板，部署极速且自动化程度高。 每月 100GB 流量，6000 分钟构建时间，支持 Serverless 函数（有一定的运行限额）。 Netlify https://www.netlify.com/ 静态网站托管的先驱，功能丰富，插件生态（Forms, Identity）非常成熟。 每月 100GB 流量，300 分钟构建时间，每月 12.5k 次函数调用，支持 1 个团队成员。 GitHub Pages https://pages.github.com/ 程序员首选，与代码仓库深度集成，完全免费且极其稳定。 完全免费。流量限额约 100GB/月，单个仓库大小限 1GB，站点大小限 1GB。 Firebase Hosting https://firebase.google.com/ Google 旗下的后端云服务，适合需要集成数据库、鉴权等全栈功能的应用。 10GB 存储空间，360MB/天 流量，免费 SSL 及自定义域名。 Render https://render.com/ 界面清爽，支持静态站、Web 服务及数据库的一站式托管。 每月 100GB 流量，无限站点，构建时长共享。 Surge.sh https://surge.sh/ 为命令行而生，一个命令完成部署，适合前端开发者快速预览 Demo。 基本无限流量。支持自定义域名，基础功能永久免费，但自定义 SSL 证书需付费。 AWS Amplify https://aws.amazon.com/amplify/ 亚马逊提供的全栈开发平台，适合已有 AWS 生态或追求企业级可靠性的项目。 每月 15GB 流量，5GB 存储，1000 分钟构建时长（免费期通常为 12 个月） Headless CMS # CMS 名称 官网地址 简介 支持数据库 Strapi https://strapi.io/ 全球最流行的开源 Node.js CMS，插件生态极强，适合各种规模项目。 SQLite, PostgreSQL, MySQL, MariaDB Directus https://directus.io/ 实时镜像您的 SQL 数据库，将其转化为 API。不产生专有模式。 PostgreSQL, MySQL, SQLite, Oracle, MS SQL Payload CMS https://payloadcms.com/ 基于 Next.js，代码优先（Code-first），开发者体验极佳。 PostgreSQL (推荐), MongoDB, SQLite Ghost https://ghost.org/ 专注于出版和博客，虽然是整体式架构，但其 Headless 模式非常成熟。 MySQL 8 (生产环境), SQLite (开发环境) KeystoneJS https://keystonejs.com/ 基于 GraphQL 和 TypeScript 的内容平台，高度可定制。 PostgreSQL, SQLite Sanity https://www.sanity.io/ 注：虽非完全开源后端，但 Studio 开源。 实时结构化内容的代表。 Content Lake (自研文档型云数据库) Decap CMS https://decapcms.org/ 原名 Netlify CMS。基于 Git 存储的 CMS，无需独立数据库。 Git 仓库 (GitHub, GitLab, Bitbucket) PocketBase https://pocketbase.io/ 单文件运行的轻量后端，自带鉴权、数据库和文件存储。 SQLite (内置，含实时订阅功能) Appwrite https://appwrite.io/ 完整的 Firebase 开源替代方案，包含强大的数据库组件。 MariaDB (底层), 支持多种后端存储适配 自动化平台 # 平台名称 官网地址 简介 免费额度 n8n https://n8n.io/ 目前最强开源替代品，节点式工作流，支持 400+ 集成。 自托管版：永久免费，无任务限额；云端版：每月 200 次执行，1 个活动工作流。 Make https://www.make.com/ 以可视化、“无限画布”著称，逻辑处理能力极强，性价比高于 Zapier。 每月 1,000 次操作 (Ops)，100MB 数据传输量，支持无限个工作流（但受限于步数）。 Zapier https://zapier.com/ 行业老牌大哥，支持的应用数量最多（6000+），上手最快。 每月 100 次任务 (Tasks)，仅支持单步自动化（1 触发 + 1 动作），15 分钟检查频率。 Activepieces https://www.activepieces.com/ AI 时代的新宠，界面极简类似 Zapier，原生支持 AI Agent 编排。 自托管版：完全免费，无任务限额；云端版：10 个活动工作流，不限任务数（限速/并发限制）。 Appsmith https://www.appsmith.com/ 侧重内部工具开发，能一键将自动化流程转化为 UI 界面。 自托管社区版：完全免费；云端版：不限应用数，每月 20 个人员小时使用时长。 Windmill https://www.windmill.dev/ 极其硬核，支持直接运行 Python/TS 脚本，适合高负载任务。 开源版：完全免费；云端版：个人开发者免费使用，支持 10 多个常用节点。 Huginn https://github.com/huginn/huginn 经典的网页监控工具，擅长复杂的 RSS 订阅和数据抓取。 完全免费 (仅支持自托管)，性能上限取决于您的服务器配置。 Node-RED https://nodered.org/ IBM 发起，最初用于物联网，现也广泛用于网页 API 联动。 完全免费 (开源项目)，无任何商业限额。 ","externalUrl":null,"permalink":"/links/links/","section":"Links","summary":"","title":"链接分享","type":"links"},{"content":" 个人介绍 # 大家好，我是文森（Vincent-SHA)，这是一个轻量型的科技站点，以最快速的静态网站系统 Hugo 构建。本网站主要热衷于关注各类科技资讯和产品新闻；搜刮各种免费资源、免费部署的开源项目；研究各种低成本创业项目。本网站主要是交流学到的各种有用无用的知识，希望能找到志同道合者一起研究如何创业。\n主要内容（皮毛知识） # 搜刮各种开源的免费资源，传播技术小白都可以看懂的技术教程，关注最新的科技资讯。 静态站点：Hugo、notionNext Hugo静态网站入门指南 2025-10-30\u0026middot;3 分钟 技术教程 Hugo 入门 静态网站 Headless CMS：SonicJS、Stripa、Decap CMS 开源后端SonicJS部署指南 2025-12-06\u0026middot;4 分钟 技术教程 后端 SonicJs 入门 部署平台：Cloudflare 自动化平台：Make 移动端应用：Swift 联系方式 \u0026amp; 社交 # 电子邮件：vincentshajing@gmail.com 主页社交： GitHub: https://github.com/vincent-sha X/Twitter: https://x.com/@vincentshaj YouTube: https://www.youtube.com/@vincentsha4819 想了解更多？欢迎在文章下方留言或通过社交联系我 — 我会尽力回复并分享有用的资源。\n","externalUrl":null,"permalink":"/about/aboutme/","section":"Abouts","summary":"","title":"网站简介","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"作者简介","summary":"","title":"作者简介","type":"authors"}]